import { Argument, Command, Option } from "commander";
import { writeFile, mkdir, readFile } from "fs/promises";
import Handlebars from "handlebars";
import path from "path";
import glob from "tiny-glob";

const MiddlewareTemplate =
  Handlebars.compile(`import { createMiddleware } from "@csi-foxbyte/fastify-toab";

export const {{lname}}Middleware = createMiddleware(async ({ ctx }, next) => {
  const newCtx = { ...ctx, /** your extra data */};

  await next({ ctx: newCtx });

  return newCtx;
});
`);

const WorkerTemplate =
  Handlebars.compile(`import { createWorker } from "@csi-foxbyte/fastify-toab";
import { Job } from "bullmq";
import defaultConnection from "../../connection{{fileExtension}}";

const {{lname}}Worker = createWorker()
    .queue("{{qname}}")
    .job<Job<{}, {}>>()
    .connection(defaultConnection)
    .processor(async () => {
        return {};
    });

/*
AUTOGENERATED!
*/

export default {{lname}}Worker;
`);

const SandboxedWorkerTemplate0 =
  Handlebars.compile(`import { createWorker } from "@csi-foxbyte/fastify-toab";
import { SandboxedJob } from "bullmq";
import defaultConnection from "../../connection{{fileExtension}}";

const {{lname}}Worker = createWorker()
    .queue("{{qname}}")
    .sandboxedJob<SandboxedJob<{}, {}>>()
    .connection(defaultConnection)
    .processor(new URL("./{{lname}}.sandboxedWorker.js", import.meta.url));

export default {{lname}}Worker;
`);

const SandboxedWorkerTemplate1 = Handlebars.compile(`import "dotenv";
import type { {{tname}}WorkerJob } from "../../@internals/index{{fileExtension}}";
import { initializeContainers } from "../../registries{{fileExtension}}";

export default async function run(
  job: {{tname}}WorkerJob
): Promise<{{tname}}WorkerJob["returnValue"]> {
  const { services } = await initializeContainers();
}
`);

const ControllerTemplate =
  Handlebars.compile(`import { createController } from "@csi-foxbyte/fastify-toab";

const {{lname}}Controller = createController()
    .rootPath("/{{lname}}")

export default {{lname}}Controller;
`);

const ServiceTemplate = Handlebars.compile(`
import { createService } from "@csi-foxbyte/fastify-toab";

const {{lname}}Service = createService("{{lname}}", async () => {
    // Your code here...
});

export default {{lname}}Service;
`);

async function createInternals(workdir: string) {
  const services = await glob("**/*.service.ts", { cwd: workdir });
  const workers = await glob("**/*.worker.ts", { cwd: workdir });

  let generated = `/*
AUTOGENERATED
*/

import { InferService, ServiceContainer, WorkerContainer, QueueContainer } from "@csi-foxbyte/fastify-toab";

`;

  let types = "";

  let imports = "";

  let getters = "";

  for (const service of services) {
    const serviceName = service
      .split(".")
      .slice(-3)[0]
      .split(path.sep)
      .slice(-1)[0];
    const serviceNameTypeName = `${capitalize(serviceName)}Service`;
    imports += `import ${serviceName}Service from "../${serviceName}/${serviceName}.service.js";\n`;

    types += `export type ${serviceNameTypeName} = InferService<typeof ${serviceName}Service>;\n`;

    getters += `export function get${serviceNameTypeName}(deps: ServiceContainer) {
    return deps.get<${serviceNameTypeName}>(${serviceName}Service.name);
}\n`;
  }

  for (const worker of workers) {
    const componentName = worker.split("\\").slice(-3)[0];

    const workerName = worker
      .split(".")
      .slice(-3)[0]
      .split(path.sep)
      .slice(-1)[0];

    const workerNameImported = `${componentName}${capitalize(
      workerName
    )}Worker`;

    const workerNameTypeBase = capitalize(workerNameImported);

    imports += `import ${workerNameImported} from "../${componentName}/workers/${workerName}.worker.js";\n`;

    types += `export type ${workerNameTypeBase} = (typeof ${workerNameImported})["worker"];\n`;
    types += `export type ${workerNameTypeBase}Queue = (typeof ${workerNameImported})["queue"];\n`;
    types += `export type ${workerNameTypeBase}Job = (typeof ${workerNameImported})["job"];\n`;

    getters += `export function get${workerNameTypeBase}(deps: WorkerContainer) {
  return deps.get<${workerNameTypeBase}>(${workerNameImported}.queueName);
}\n`;
    getters += `export function get${workerNameTypeBase}Queue(deps: QueueContainer) {
  return deps.get<${workerNameTypeBase}Queue>(${workerNameImported}.queueName);
}\n`;
  }

  generated += imports + "\n";
  generated += types + "\n";
  generated += getters + "\n";

  return generated;
}

async function createRegistries(
  workdir: string,
  emitJsWithFileEnding: boolean
) {
  const services = await glob("**/*.service.ts", { cwd: workdir });
  const controllers = await glob("**/*.controller.ts", { cwd: workdir });
  const workers = await glob("**/*.worker.ts", { cwd: workdir });

  let generated = `/*
AUTOGENERATED!
*/

import {
  ControllerRegistry,
  ServiceRegistry,
  WorkerRegistry,
} from "@csi-foxbyte/fastify-toab";`;

  function mapImport({ id, path }: { path: string; id: string }) {
    return `import ${id} from "./${path
      .split(".")
      .slice(0, -1)
      .join(".")
      .split("\\")
      .join("/")}${emitJsWithFileEnding ? ".js" : ""}";`;
  }

  function mapIdAndPath(path: string) {
    return {
      path,
      id: "p_" + crypto.randomUUID().split("-").join(""),
    };
  }

  const servicesNameAndPath = services.map(mapIdAndPath);
  const workersNameAndPath = workers.map(mapIdAndPath);
  const controllersNameAndPath = controllers.map(mapIdAndPath);

  generated += servicesNameAndPath
    .map(mapImport)
    .concat(workersNameAndPath.map(mapImport))
    .concat(controllersNameAndPath.map(mapImport))
    .join("\n");

  generated += "\n";

  generated += `
export async function getRegistries(dontInitializeWorkers?: boolean) {
  let workerRegistryRef: { current: WorkerRegistry | null } = {
    current: null,
  };

  const serviceRegistry = new ServiceRegistry(workerRegistryRef);
${servicesNameAndPath
  .map(({ id }) => `  serviceRegistry.register(${id});`)
  .join("\n")}

  const workerRegistry = new WorkerRegistry(serviceRegistry);
${workersNameAndPath
  .map(
    ({ id }) => `  await workerRegistry.register(${id}, dontInitializeWorkers);`
  )
  .join("\n")}
  workerRegistryRef.current = workerRegistry;

  await workerRegistry.resumeQueues();

  const controllerRegistry = new ControllerRegistry(serviceRegistry);
${controllersNameAndPath
  .map(({ id }) => `  controllerRegistry.register(${id});`)
  .join("\n")}

  return { controllerRegistry, serviceRegistry, workerRegistry };
}

/**
 * Use this function inside a sandboxedWorker to gain access to services and other workers.
 */
export async function initializeContainers() {
  const { serviceRegistry, workerRegistry } = await getRegistries(true);

  return {
    services: serviceRegistry.resolve(),
    queues: { get: workerRegistry.getQueue.bind(workerRegistry) },
  };
}
`;

  return generated;
}

function capitalize(word: string) {
  return word.charAt(0).toUpperCase() + word.slice(1);
}

function uncapitalize(word: string) {
  return word.charAt(0).toLowerCase() + word.slice(1);
}

const program = new Command();

program
  .name("fastify-toab")
  .description("CLI to create services, workers and controllers easily.")
  .version("0.1.0");

program
  .command("rebuild")
  .description("rebuild registries")
  .addOption(
    new Option(
      "-w, --workdir <path>",
      "workdir to operate in is src at default."
    )
  )
  .action(async (options) => {
    const configRaw = await readFile(".fastify-toab.rc.json");

    let config = JSON.parse(configRaw.toString()) as {
      workdir?: string;
      emitWithJsEnding?: boolean;
    };

    config = {
      workdir: options.workdir ?? config.workdir ?? "src",
      emitWithJsEnding: config.emitWithJsEnding ?? false,
    };

    const workdir = path.join(
      process.cwd(),
      options.workdir ?? config.workdir ?? "src"
    );

    const internals = await createInternals(workdir);

    await mkdir(path.join(workdir, "@internals"), { recursive: true });

    await writeFile(path.join(workdir, "@internals", "index.ts"), internals);

    const registries = await createRegistries(
      workdir,
      config.emitWithJsEnding ?? false
    );

    await writeFile(path.join(workdir, "registries.ts"), registries);
  });

program
  .command("create")
  .description("create a component")
  .addArgument(
    new Argument("<component>", "component to create").choices([
      "service",
      "controller",
      "worker",
      "sandboxedWorker",
      "middleware",
    ])
  )
  .addArgument(
    new Argument("<nameOrParent>", "component name or worker parent")
  )
  .addArgument(new Argument("<workerName>", "worker name").argOptional())
  .addOption(
    new Option(
      "-w, --workdir <path>",
      "workdir to operate in is src at default."
    )
  )
  .action(async (component, nameOrParent, workerName, options) => {
    if (
      (component === "worker" || component === "sandboxedWorker") &&
      !workerName
    )
      throw new Error("No workerName for worker supplied!");

    const configRaw = await readFile(".fastify-toab.rc.json");

    let config = JSON.parse(configRaw.toString()) as {
      workdir?: string;
      emitWithJsEnding?: boolean;
    };

    config = {
      workdir: options.workdir ?? config.workdir ?? "src",
      emitWithJsEnding: config.emitWithJsEnding ?? false,
    };

    const workdir = path.join(
      process.cwd(),
      options.workdir ?? config.workdir ?? "src"
    );

    await mkdir(path.join(workdir, nameOrParent), { recursive: true });

    switch (component) {
      case "controller": {
        const cname = capitalize(nameOrParent);
        const lname = uncapitalize(nameOrParent);
        const template = ControllerTemplate({ cname, lname });
        await writeFile(
          path.join(workdir, nameOrParent, `${lname}.controller.ts`),
          template
        );
        await writeFile(
          path.join(workdir, nameOrParent, `${lname}.dto.ts`),
          `import { Static, Type } from "@sinclair/typebox";\n\n`
        );
        break;
      }
      case "service": {
        const cname = capitalize(nameOrParent);
        const lname = uncapitalize(nameOrParent);
        const template = ServiceTemplate({ cname, lname });
        await writeFile(
          path.join(workdir, nameOrParent, `${lname}.service.ts`),
          template
        );
        break;
      }
      case "sandboxedWorker":
        const cname = capitalize(workerName);
        const lname = uncapitalize(workerName);
        const mlname = uncapitalize(nameOrParent);
        const tname = capitalize(nameOrParent) + cname;
        const qname = `{${mlname}-${lname}-queue}`;
        await mkdir(path.join(workdir, nameOrParent, "workers"), {
          recursive: true,
        });
        const template0 = SandboxedWorkerTemplate0({
          cname,
          lname,
          qname,
          tname,
          mlname,
          fileExtension: config.emitWithJsEnding ? ".js" : "",
        });
        await writeFile(
          path.join(workdir, nameOrParent, "workers", `${lname}.worker.ts`),
          template0
        );
        const template1 = SandboxedWorkerTemplate1({
          cname,
          lname,
          mlname,
          qname,
          tname,
          fileExtension: config.emitWithJsEnding ? ".js" : "",
        });
        await writeFile(
          path.join(
            workdir,
            nameOrParent,
            "workers",
            `${lname}.sandboxedWorker.ts`
          ),
          template1
        );
        break;
      case "worker": {
        const cname = capitalize(workerName);
        const lname = uncapitalize(workerName);
        const mlname = uncapitalize(nameOrParent);
        const qname = `{${mlname}-${lname}-queue}`;
        const tname = capitalize(nameOrParent) + cname;
        await mkdir(path.join(workdir, nameOrParent, "workers"), {
          recursive: true,
        });
        const template = WorkerTemplate({
          cname,
          lname,
          mlname,
          tname,
          qname,
          fileExtension: config.emitWithJsEnding ? ".js" : "",
        });
        await writeFile(
          path.join(workdir, nameOrParent, "workers", `${lname}.worker.ts`),
          template
        );
        break;
      }
      case "middleware": {
        const cname = capitalize(nameOrParent);
        const lname = uncapitalize(nameOrParent);
        const template = MiddlewareTemplate({ cname, lname });
        await writeFile(
          path.join(workdir, nameOrParent, `${lname}.middleware.ts`),
          template
        );
        break;
      }
    }

    const internals = await createInternals(workdir);

    await mkdir(path.join(workdir, "@internals"), { recursive: true });

    await writeFile(path.join(workdir, "@internals", "index.ts"), internals);

    const registries = await createRegistries(
      workdir,
      config.emitWithJsEnding ?? false
    );

    await writeFile(path.join(workdir, "registries.ts"), registries);
  });

program.parse();
