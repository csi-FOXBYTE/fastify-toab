import { Argument, Command, Option } from "commander";
import { writeFile, mkdir } from "fs/promises";
import Handlebars from "handlebars";
import path from "path";
import glob from "tiny-glob";

const WorkerTemplate =
  Handlebars.compile(`import { createWorker, QueueContainer, WorkerContainer, Job } from "..";

const {{lname}}Worker = createWorker()
    .queue("{{lname}}-queue")
    .job<Job<{}, {}>>()
    .connection({})
    .processor(async () => {
        return {};
    });

/*
AUTOGENERATED!
*/

export { {{lname}}Worker };
export type {{cname}}Worker = (typeof {{lname}}Worker)["worker"];
export type {{cname}}WorkerQueue = (typeof {{lname}}Worker)["queue"];

export function get{{cname}}Worker(deps: WorkerContainer) {
    return deps.get<{{cname}}Worker>({{lname}}Worker.queueName);
}
export function get{{cname}}WorkerQueue(deps: QueueContainer) {
    return deps.get<{{cname}}WorkerQueue>({{lname}}Worker.queueName);
}
`);

const ControllerTemplate =
  Handlebars.compile(`import { createController } from "..";

const {{lname}}Controller = createController()
    .rootPath("/{{lname}}")

/*
AUTOGENERATED!
*/

export { {{lname}}Controller };
`);

const ServiceTemplate = Handlebars.compile(`
import {
  createService,
  InferService,
  ServiceContainer,
} from "..";

const {{lname}}Service = createService("{{lname}}", async () => {
    // Your code here...
});

export { {{lname}}Service };
export type {{cname}}Service = InferService<typeof {{lname}}Service>;
export function get{{cname}}Service(deps: ServiceContainer) {
    return deps.get<{{cname}}Service>({{lname}}Service.name);
}
`);

async function createRegistries(workdir: string) {
  const services = await glob("**/*.service.ts", { cwd: workdir });
  const controllers = await glob("**/*.controller.ts", { cwd: workdir });
  const workers = await glob("**/*.worker.ts", { cwd: workdir });

  let generated = `/*
AUTOGENERATED!
*/

import {
  ControllerRegistry,
  ServiceRegistry,
  WorkerRegistry,
} from "../src/index";

`;

  function mapImport({ name, path }: { name: string; path: string }) {
    return `import { ${name} } from "./${path
      .split(".")
      .slice(0, -1)
      .join(".")
      .split("\\")
      .join("/")}";`;
  }

  function mapNameAndPath(
    path: string,
    component: "Service" | "Worker" | "Controller"
  ) {
    const name = path.split(".").slice(-3)[0].split("\\").slice(-1) + component;

    return {
      name,
      path,
    };
  }

  const servicesNameAndPath = services.map((path) =>
    mapNameAndPath(path, "Service")
  );
  const workersNameAndPath = workers.map((path) =>
    mapNameAndPath(path, "Worker")
  );
  const controllersNameAndPath = controllers.map((path) =>
    mapNameAndPath(path, "Controller")
  );

  generated += servicesNameAndPath
    .map(mapImport)
    .concat(workersNameAndPath.map(mapImport))
    .concat(controllersNameAndPath.map(mapImport))
    .join("\n");

  generated += "\n";

  generated += `
export async function getRegistries() {
  let workerRegistryRef: { current: WorkerRegistry | null } = {
    current: null,
  };

  const serviceRegistry = new ServiceRegistry(workerRegistryRef);
${servicesNameAndPath
  .map(({ name }) => `  serviceRegistry.register(${name});`)
  .join("\n")}

  const workerRegistry = new WorkerRegistry(serviceRegistry);
${workersNameAndPath
  .map(({ name }) => `  await workerRegistry.register(${name});`)
  .join("\n")}

  const controllerRegistry = new ControllerRegistry(serviceRegistry);
${controllersNameAndPath
  .map(({ name }) => `  controllerRegistry.register(${name});`)
  .join("\n")}

  return { controllerRegistry, serviceRegistry, workerRegistry };
}`;

  return generated;
}

function capitalize(word: string) {
  return word.charAt(0).toUpperCase() + word.slice(1);
}

function uncapitalize(word: string) {
  return word.charAt(0).toLowerCase() + word.slice(1);
}

const program = new Command();

program
  .name("fastify-toa")
  .description("CLI to create services, workers and controllers easily.")
  .version("0.0.1");

program
  .command("create")
  .description("create a component")
  .addArgument(
    new Argument("<component>", "component to create").choices([
      "service",
      "controller",
      "worker",
    ])
  )
  .addArgument(
    new Argument("<nameOrParent>", "component name or worker parent")
  )
  .addArgument(new Argument("<workerName>", "worker name").argOptional())
  .addOption(
    new Option(
      "-w, --workdir <path>",
      "workdir to operate in is src at default."
    )
  )
  .action(async (component, nameOrParent, workerName, options) => {
    if (component === "worker" && !workerName)
      throw new Error("No workerName for worker supplied!");
    const workdir = path.join(process.cwd(), options.workdir ?? "src");

    await mkdir(path.join(workdir, nameOrParent), { recursive: true });

    switch (component) {
      case "controller": {
        const cname = capitalize(nameOrParent);
        const lname = uncapitalize(nameOrParent);
        const template = ControllerTemplate({ cname, lname });
        await writeFile(
          path.join(workdir, nameOrParent, `${lname}.controller.ts`),
          template
        );
        break;
      }
      case "service": {
        const cname = capitalize(nameOrParent);
        const lname = uncapitalize(nameOrParent);
        const template = ServiceTemplate({ cname, lname });
        await writeFile(
          path.join(workdir, nameOrParent, `${lname}.service.ts`),
          template
        );
        break;
      }
      case "worker": {
        const cname = capitalize(workerName);
        const lname = uncapitalize(workerName);
        await mkdir(path.join(workdir, nameOrParent, "workers"), {
          recursive: true,
        });
        const template = WorkerTemplate({ cname, lname });
        await writeFile(
          path.join(workdir, nameOrParent, "workers", `${lname}.worker.ts`),
          template
        );
        break;
      }
    }

    const registries = await createRegistries(workdir);

    await writeFile(path.join(workdir, "registries.ts"), registries);
  });

program.parse();
