import { Argument, Command, Option } from "commander";
import { writeFile, mkdir, readFile, stat } from "fs/promises";
import Handlebars from "handlebars";
import path from "path";
import glob from "tiny-glob";

const MiddlewareTemplate =
  Handlebars.compile(`import { createMiddleware } from "@csi-foxbyte/fastify-toab";

export const {{lname}}Middleware = createMiddleware(async ({ ctx }, next) => {
  const newCtx = { ...ctx, /** your extra data */};

  await next({ ctx: newCtx });

  return newCtx;
});
`);

const WorkerTemplate =
  Handlebars.compile(`import { createWorker, QueueContainer, WorkerContainer } from "@csi-foxbyte/fastify-toab";
import { Job } from "bullmq";
import defaultConnection from "../../connection{{fileExtension}}";

const {{lname}}Worker = createWorker()
    .queue("{{lname}}-queue")
    .job<Job<{}, {}>>()
    .connection(defaultConnection)
    .processor(async () => {
        return {};
    });

/*
AUTOGENERATED!
*/

export { {{lname}}Worker };
export type {{cname}}Worker = (typeof {{lname}}Worker)["worker"];
export type {{cname}}WorkerQueue = (typeof {{lname}}Worker)["queue"];
export type {{cname}}WorkerJob = (typeof {{lname}}Worker)["job"];

export function get{{cname}}Worker(deps: WorkerContainer) {
    return deps.get<{{cname}}Worker>({{lname}}Worker.queueName);
}
export function get{{cname}}WorkerQueue(deps: QueueContainer) {
    return deps.get<{{cname}}WorkerQueue>({{lname}}Worker.queueName);
}
`);

const SandboxedWorkerTemplate0 =
  Handlebars.compile(`import { createWorker, QueueContainer, WorkerContainer } from "@csi-foxbyte/fastify-toab";
import { SandboxedJob } from "bullmq";
import defaultConnection from "../../connection{{fileExtension}}";

const {{lname}}Worker = createWorker()
    .queue("{{lname}}-queue")
    .sandboxedJob<SandboxedJob<{}, {}>>()
    .connection(defaultConnection)
    .processor(new URL("./{{lname}}.sandboxedWorker.js", import.meta.url));

/*
AUTOGENERATED!
*/

export { {{lname}}Worker };
export type {{cname}}Worker = (typeof {{lname}}Worker)["worker"];
export type {{cname}}WorkerQueue = (typeof {{lname}}Worker)["queue"];
export type {{cname}}WorkerJob = (typeof {{lname}}Worker)["job"];

export function get{{cname}}Worker(deps: WorkerContainer) {
    return deps.get<{{cname}}Worker>({{lname}}Worker.queueName);
}
export function get{{cname}}WorkerQueue(deps: QueueContainer) {
    return deps.get<{{cname}}WorkerQueue>({{lname}}Worker.queueName);
}
`);

const SandboxedWorkerTemplate1 = Handlebars.compile(`import "dotenv";
import type { {{cname}}WorkerJob } from "./{{mlname}}.{{lname}}.worker{{fileExtension}}";
import { getRegistries } from "../../registries{{fileExtension}}";

async function initializeContainers() {
  const { serviceRegistry, workerRegistry } = await getRegistries();

  return {
    services: serviceRegistry.resolve(),
    queues: { get: workerRegistry.getQueue.bind(workerRegistry) },
  };
}

export default async function run(
  job: {{cname}}WorkerJob
): Promise<{{cname}}WorkerJob["returnValue"]> {

}
`);

const ControllerTemplate =
  Handlebars.compile(`import { createController } from "@csi-foxbyte/fastify-toab";

const {{lname}}Controller = createController()
    .rootPath("/{{lname}}")

/*
AUTOGENERATED!
*/

export { {{lname}}Controller };
`);

const ServiceTemplate = Handlebars.compile(`
import {
  createService,
  InferService,
  ServiceContainer,
} from "@csi-foxbyte/fastify-toab";

const {{lname}}Service = createService("{{lname}}", async () => {
    // Your code here...
});

/*
AUTOGENERATED!
*/

export { {{lname}}Service };
export type {{cname}}Service = InferService<typeof {{lname}}Service>;
export function get{{cname}}Service(deps: ServiceContainer) {
    return deps.get<{{cname}}Service>({{lname}}Service.name);
}
`);

async function createRegistries(
  workdir: string,
  emitJsWithFileEnding: boolean
) {
  const services = await glob("**/*.service.ts", { cwd: workdir });
  const controllers = await glob("**/*.controller.ts", { cwd: workdir });
  const workers = await glob("**/*.worker.ts", { cwd: workdir });

  let generated = `/*
AUTOGENERATED!
*/

import {
  ControllerRegistry,
  ServiceRegistry,
  WorkerRegistry,
} from "@csi-foxbyte/fastify-toab";

`;

  function mapImport({ name, path }: { name: string; path: string }) {
    return `import { ${name} } from "./${path
      .split(".")
      .slice(0, -1)
      .join(".")
      .split("\\")
      .join("/")}${emitJsWithFileEnding ? ".js" : ""}";`;
  }

  function mapNameAndPath(
    path: string,
    component: "Service" | "Worker" | "Controller"
  ) {
    const name = path.split(".").slice(-3)[0].split("\\").slice(-1) + component;

    return {
      name,
      path,
    };
  }

  const servicesNameAndPath = services.map((path) =>
    mapNameAndPath(path, "Service")
  );
  const workersNameAndPath = workers.map((path) =>
    mapNameAndPath(path, "Worker")
  );
  const controllersNameAndPath = controllers.map((path) =>
    mapNameAndPath(path, "Controller")
  );

  generated += servicesNameAndPath
    .map(mapImport)
    .concat(workersNameAndPath.map(mapImport))
    .concat(controllersNameAndPath.map(mapImport))
    .join("\n");

  generated += "\n";

  generated += `
export async function getRegistries(dontInitializeWorkers?: boolean) {
  let workerRegistryRef: { current: WorkerRegistry | null } = {
    current: null,
  };

  const serviceRegistry = new ServiceRegistry(workerRegistryRef);
${servicesNameAndPath
  .map(({ name }) => `  serviceRegistry.register(${name});`)
  .join("\n")}

  const workerRegistry = new WorkerRegistry(serviceRegistry);
${workersNameAndPath
  .map(
    ({ name }) =>
      `  await workerRegistry.register(${name}, dontInitializeWorkers);`
  )
  .join("\n")}
  workerRegistryRef.current = workerRegistry;

  await workerRegistry.resumeQueues();

  const controllerRegistry = new ControllerRegistry(serviceRegistry);
${controllersNameAndPath
  .map(({ name }) => `  controllerRegistry.register(${name});`)
  .join("\n")}

  return { controllerRegistry, serviceRegistry, workerRegistry };
}`;

  return generated;
}

function capitalize(word: string) {
  return word.charAt(0).toUpperCase() + word.slice(1);
}

function uncapitalize(word: string) {
  return word.charAt(0).toLowerCase() + word.slice(1);
}

const program = new Command();

program
  .name("fastify-toa")
  .description("CLI to create services, workers and controllers easily.")
  .version("0.0.1");

program
  .command("rebuild")
  .description("rebuild registries")
  .addOption(
    new Option(
      "-w, --workdir <path>",
      "workdir to operate in is src at default."
    )
  )
  .action(async (options) => {
    const configRaw = await readFile(".fastify-toab.rc.json");

    let config = JSON.parse(configRaw.toString()) as {
      workdir?: string;
      emitWithJsEnding?: boolean;
    };

    config = {
      workdir: options.workdir ?? config.workdir ?? "src",
      emitWithJsEnding: config.emitWithJsEnding ?? false,
    };

    const workdir = path.join(
      process.cwd(),
      options.workdir ?? config.workdir ?? "src"
    );

    const registries = await createRegistries(
      workdir,
      config.emitWithJsEnding ?? false
    );

    await writeFile(path.join(workdir, "registries.ts"), registries);
  });

program
  .command("create")
  .description("create a component")
  .addArgument(
    new Argument("<component>", "component to create").choices([
      "service",
      "controller",
      "worker",
      "sandboxedWorker",
      "middleware",
    ])
  )
  .addArgument(
    new Argument("<nameOrParent>", "component name or worker parent")
  )
  .addArgument(new Argument("<workerName>", "worker name").argOptional())
  .addOption(
    new Option(
      "-w, --workdir <path>",
      "workdir to operate in is src at default."
    )
  )
  .action(async (component, nameOrParent, workerName, options) => {
    if (
      (component === "worker" ||
      component === "sandboxedWorker") && !workerName
    )
      throw new Error("No workerName for worker supplied!");

    const configRaw = await readFile(".fastify-toab.rc.json");

    let config = JSON.parse(configRaw.toString()) as {
      workdir?: string;
      emitWithJsEnding?: boolean;
    };

    config = {
      workdir: options.workdir ?? config.workdir ?? "src",
      emitWithJsEnding: config.emitWithJsEnding ?? false,
    };

    const workdir = path.join(
      process.cwd(),
      options.workdir ?? config.workdir ?? "src"
    );

    await mkdir(path.join(workdir, nameOrParent), { recursive: true });

    switch (component) {
      case "controller": {
        const cname = capitalize(nameOrParent);
        const lname = uncapitalize(nameOrParent);
        const template = ControllerTemplate({ cname, lname });
        await writeFile(
          path.join(workdir, nameOrParent, `${lname}.controller.ts`),
          template
        );
        break;
      }
      case "service": {
        const cname = capitalize(nameOrParent);
        const lname = uncapitalize(nameOrParent);
        const template = ServiceTemplate({ cname, lname });
        await writeFile(
          path.join(workdir, nameOrParent, `${lname}.service.ts`),
          template
        );
        break;
      }
      case "sandboxedWorker":
        const cname = capitalize(workerName);
        const lname = uncapitalize(workerName);
        const mlname = uncapitalize(nameOrParent);
        await mkdir(path.join(workdir, nameOrParent, "workers"), {
          recursive: true,
        });
        const template0 = SandboxedWorkerTemplate0({
          cname,
          lname,
          mlname,
          fileExtension: config.emitWithJsEnding ? ".js" : "",
        });
        await writeFile(
          path.join(
            workdir,
            nameOrParent,
            "workers",
            `${mlname}.${lname}.worker.ts`
          ),
          template0
        );
        const template1 = SandboxedWorkerTemplate1({
          cname,
          lname,
          mlname,
          fileExtension: config.emitWithJsEnding ? ".js" : "",
        });
        await writeFile(
          path.join(
            workdir,
            nameOrParent,
            "workers",
            `${mlname}.${lname}.sandboxedWorker.ts`
          ),
          template1
        );
        break;
      case "worker": {
        const cname = capitalize(workerName);
        const lname = uncapitalize(workerName);
        const mlname = uncapitalize(nameOrParent);
        await mkdir(path.join(workdir, nameOrParent, "workers"), {
          recursive: true,
        });
        const template = WorkerTemplate({
          cname,
          lname,
          mlname,
          fileExtension: config.emitWithJsEnding ? ".js" : "",
        });
        await writeFile(
          path.join(
            workdir,
            nameOrParent,
            "workers",
            `${mlname}.${lname}.worker.ts`
          ),
          template
        );
        break;
      }
      case "middleware": {
        const cname = capitalize(nameOrParent);
        const lname = uncapitalize(nameOrParent);
        const template = MiddlewareTemplate({ cname, lname });
        await writeFile(
          path.join(workdir, nameOrParent, `${lname}.middleware.ts`),
          template
        );
        break;
      }
    }

    const registries = await createRegistries(
      workdir,
      config.emitWithJsEnding ?? false
    );

    await writeFile(path.join(workdir, "registries.ts"), registries);
  });

program.parse();
