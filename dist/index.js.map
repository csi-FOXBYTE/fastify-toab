{"version":3,"sources":["../src/worker.ts","../src/route.ts","../src/controller.ts","../src/context.ts","../src/service.ts","../src/middleware.ts"],"names":["WorkerRegistry","serviceRegistry","workerCtx","queue","Queue","jobScheduler","worker","Worker","job","token","e","onHandler","args","onceHandler","name","createWorker","ctx","workerHandler","queueName","queueOptions","proxy","connection","options","processor","target","p","receiver","createRoute","routerHandler","body","output","params","querystring","handler","opts","createController","rootPath","method","path","fn","ControllerRegistry","controller","controllerCtx","contextLocalStorage","AsyncLocalStorage","getRequestContext","store","ServiceRegistry","workerRegistryRef","factory","scope","requestScopedInstances","resolving","container","definition","cache","instance","createService","createMiddleware"],"mappings":"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","file":"index.js","sourcesContent":["import {\r\n  ConnectionOptions,\r\n  Job,\r\n  JobSchedulerTemplateOptions,\r\n  Queue,\r\n  QueueOptions,\r\n  RepeatOptions,\r\n  SandboxedJob,\r\n  Worker,\r\n  WorkerListener,\r\n  WorkerOptions,\r\n} from \"bullmq\";\r\nimport { ServiceContainer, ServiceRegistry } from \"./service\";\r\n\r\nexport interface WorkerContainer {\r\n  get: WorkerRegistry[\"getWorker\"];\r\n}\r\n\r\nexport interface QueueContainer {\r\n  get: WorkerRegistry[\"getQueue\"];\r\n}\r\n\r\nexport interface WorkerCtx<Q extends Queue, W extends Worker> {\r\n  queueName: string;\r\n  queueOptions?: QueueOptions;\r\n  jobSchedulers: Parameters<\r\n    WorkerC<\"\", Job<any, any, any>, null>[\"upsertJobScheduler\"]\r\n  >[];\r\n  onHandlers: Parameters<WorkerC<\"\", Job<any, any, any>, null>[\"on\"]>[];\r\n  onceHandlers: Parameters<WorkerC<\"\", Job<any, any, any>, null>[\"on\"]>[];\r\n  isSandboxed: boolean;\r\n  connection: ConnectionOptions;\r\n  options?: WorkerOptions;\r\n  processor:\r\n    | string\r\n    | URL\r\n    | ((\r\n        job: Job<any, any, any>,\r\n        ctx: {\r\n          services: ReturnType<ServiceRegistry[\"resolve\"]>;\r\n          workers: WorkerContainer;\r\n          queues: QueueContainer;\r\n        },\r\n        token?: string\r\n      ) => Promise<any>);\r\n  queue: Q; // only type\r\n  worker: W; // only type\r\n}\r\n\r\nexport class WorkerRegistry {\r\n  private readonly queues = new Map<string, Queue>();\r\n  private readonly workers = new Map<string, Worker>();\r\n  private readonly serviceRegistry: ServiceRegistry;\r\n\r\n  constructor(serviceRegistry: ServiceRegistry) {\r\n    this.serviceRegistry = serviceRegistry;\r\n  }\r\n\r\n  async register<\r\n    Q extends Queue<any, any, any, any, any>,\r\n    W extends Worker<any, any, any>\r\n  >(workerCtx: WorkerCtx<Q, W>) {\r\n    if (this.queues.has(workerCtx.queueName)) {\r\n      throw new Error(\r\n        `Queue with name \"${workerCtx.queueName}\" is already registered.`\r\n      );\r\n    }\r\n\r\n    const queue = new Queue(workerCtx.queueName, {\r\n      ...workerCtx.queueOptions,\r\n      connection: workerCtx.connection,\r\n    });\r\n\r\n    this.queues.set(queue.name, queue);\r\n\r\n    for (const jobScheduler of workerCtx.jobSchedulers) {\r\n      await queue.upsertJobScheduler(...jobScheduler);\r\n    }\r\n\r\n    if (this.workers.has(workerCtx.queueName)) {\r\n      throw new Error(\r\n        `Queue with name \"${workerCtx.queueName}\" is already registered.`\r\n      );\r\n    }\r\n\r\n    const worker = new Worker(\r\n      workerCtx.queueName,\r\n      typeof workerCtx.processor === \"function\"\r\n        ? async (job, token) => {\r\n            if (typeof workerCtx.processor !== \"function\")\r\n              throw new Error(\r\n                \"Processor was not a function but was expected to be one.\"\r\n              );\r\n\r\n            try {\r\n              const result = await workerCtx.processor(\r\n                job,\r\n                {\r\n                  services: this.serviceRegistry.resolve(),\r\n                  workers: {\r\n                    get: this.getWorker.bind(this),\r\n                  },\r\n                  queues: {\r\n                    get: this.getQueue.bind(this),\r\n                  },\r\n                },\r\n                token\r\n              );\r\n              return result;\r\n            } catch (e) {\r\n              console.error(`Error in processor ${workerCtx.queueName}`, e);\r\n              throw e;\r\n            }\r\n          }\r\n        : workerCtx.processor,\r\n      { ...workerCtx.options, connection: workerCtx.connection }\r\n    );\r\n\r\n    for (const onHandler of workerCtx.onHandlers) {\r\n      worker.on(onHandler[0], async (...args: any[]) => {\r\n        try {\r\n          // @ts-expect-error wrong type\r\n          return await onHandler[1](...args);\r\n        } catch (e) {\r\n          console.error(`Error in worker on \"${onHandler[0]}\" handler.`, e);\r\n        }\r\n      });\r\n    }\r\n\r\n    for (const onceHandler of workerCtx.onceHandlers) {\r\n      worker.once(onceHandler[0], async (...args: any[]) => {\r\n        try {\r\n          // @ts-expect-error wrong type\r\n          return await onceHandler[1](...args);\r\n        } catch (e) {\r\n          console.error(`Error in worker once \"${onceHandler[0]}\" handler.`, e);\r\n        }\r\n      });\r\n    }\r\n\r\n    this.workers.set(workerCtx.queueName, worker);\r\n  }\r\n\r\n  getQueue<Q extends Queue>(name: string) {\r\n    const queue = this.queues.get(name);\r\n\r\n    if (!queue) {\r\n      throw new Error(`No queue named \"${name}\" found.`);\r\n    }\r\n\r\n    return queue as Q;\r\n  }\r\n\r\n  getWorker<W extends Worker>(name: string) {\r\n    const worker = this.workers.get(name);\r\n\r\n    if (!worker) {\r\n      throw new Error(`No Worker named \"${name}\" found.`);\r\n    }\r\n\r\n    return worker as W;\r\n  }\r\n}\r\n\r\nexport interface WorkerC<\r\n  Omitter extends string,\r\n  J extends Job<any, any, any> | null,\r\n  SJ extends SandboxedJob<any, any> | null\r\n> {\r\n  queue: (\r\n    queueName: string,\r\n    queueOptions?: QueueOptions\r\n  ) => Pick<\r\n    WorkerC<Omitter | \"queue\" | \"processor\", J, SJ>,\r\n    \"sandboxedJob\" | \"job\"\r\n  >;\r\n  job<NewJob extends Job<any, any, any>>(): Omit<\r\n    WorkerC<Omitter | \"job\" | \"sandboxedJob\", NewJob, SJ>,\r\n    Omitter | \"job\" | \"sandboxedJob\"\r\n  >;\r\n  sandboxedJob<NewSandboxedJob extends SandboxedJob<any, any>>(): Omit<\r\n    WorkerC<Omitter | \"sandboxedJob\" | \"job\", J, NewSandboxedJob>,\r\n    Omitter | \"sandboxedJob\" | \"job\"\r\n  >;\r\n  options: (\r\n    options: WorkerOptions\r\n  ) => Omit<WorkerC<Omitter | \"options\", J, SJ>, Omitter | \"options\">;\r\n  connection: (\r\n    connection: ConnectionOptions\r\n  ) => Pick<WorkerC<Omitter | \"connection\", J, SJ>, \"processor\">;\r\n  processor: J extends Job<infer T, infer R, infer N>\r\n    ? (\r\n        processor: (\r\n          job: Job<T, R, N>,\r\n          ctx: {\r\n            services: ServiceContainer;\r\n            workers: {\r\n              get: WorkerRegistry[\"getWorker\"];\r\n            };\r\n            queues: {\r\n              get: WorkerRegistry[\"getQueue\"];\r\n            };\r\n          },\r\n          token?: string\r\n        ) => Promise<R>\r\n      ) => WorkerCtx<Queue<T, R, N>, Worker<T, R, string>>\r\n    : SJ extends SandboxedJob<infer T, infer R>\r\n    ? (\r\n        url: string | URL\r\n      ) => WorkerCtx<Queue<T, R, string>, Worker<T, R, string>>\r\n    : never;\r\n  upsertJobScheduler: J extends Job<infer T, infer R, infer N>\r\n    ? (\r\n        jobSchedulerId: string,\r\n        repeatOpts: Omit<RepeatOptions, \"key\">,\r\n        jobTemplate?: {\r\n          name?: N;\r\n          data?: T;\r\n          opts?: JobSchedulerTemplateOptions;\r\n        }\r\n      ) => Omit<WorkerC<Omitter, J, SJ>, Omitter>\r\n    : SJ extends SandboxedJob<infer T>\r\n    ? (\r\n        jobSchedulerId: string,\r\n        repeatOpts: Omit<RepeatOptions, \"key\">,\r\n        jobTemplate?: {\r\n          name?: string;\r\n          data?: T;\r\n          opts?: JobSchedulerTemplateOptions;\r\n        }\r\n      ) => Omit<WorkerC<Omitter, J, SJ>, Omitter>\r\n    : never;\r\n  on: J extends Job<infer T, infer R, infer N>\r\n    ? <Key extends keyof WorkerListener<T, R, N>>(\r\n        event: Key,\r\n        listener: WorkerListener<T, R, N>[Key]\r\n      ) => Omit<WorkerC<Omitter, J, SJ>, Omitter>\r\n    : SJ extends SandboxedJob<infer T, infer R>\r\n    ? <Key extends keyof WorkerListener<T, R, string>>(\r\n        event: Key,\r\n        listener: WorkerListener<T, R, string>[Key]\r\n      ) => Omit<WorkerC<Omitter, J, SJ>, Omitter>\r\n    : never;\r\n  once: J extends Job<infer T, infer R, infer N>\r\n    ? <Key extends keyof WorkerListener<T, R, N>>(\r\n        event: Key,\r\n        listener: WorkerListener<T, R, N>[Key]\r\n      ) => Omit<WorkerC<Omitter, J, SJ>, Omitter>\r\n    : SJ extends SandboxedJob<infer T, infer R>\r\n    ? <Key extends keyof WorkerListener<T, R, string>>(\r\n        event: Key,\r\n        listener: WorkerListener<T, R, string>[Key]\r\n      ) => Omit<WorkerC<Omitter, J, SJ>, Omitter>\r\n    : never;\r\n}\r\n\r\nexport function createWorker<Omitter extends string = \"\">(): Pick<\r\n  WorkerC<Omitter, null, null>,\r\n  \"queue\"\r\n> {\r\n  const ctx: WorkerCtx<any, any> = {\r\n    queueName: \"\",\r\n    jobSchedulers: [],\r\n    onceHandlers: [],\r\n    queue: null,\r\n    connection: {},\r\n    worker: null,\r\n    processor: \"\",\r\n    onHandlers: [],\r\n    isSandboxed: false,\r\n  };\r\n\r\n  const workerHandler: WorkerC<Omitter, Job<any, any, any>, null> = {\r\n    // @ts-expect-error wrong types\r\n    queue(queueName, queueOptions) {\r\n      ctx.queueOptions = queueOptions;\r\n      ctx.queueName = queueName;\r\n      return proxy;\r\n    },\r\n    connection(connection) {\r\n      ctx.connection = connection;\r\n      return proxy;\r\n    },\r\n    // @ts-expect-error wrong types\r\n    job() {\r\n      ctx.isSandboxed = false;\r\n      return proxy;\r\n    },\r\n    on(...args) {\r\n      ctx.onHandlers.push(args);\r\n      return proxy;\r\n    },\r\n    once(...args) {\r\n      ctx.onceHandlers.push(args);\r\n      return proxy;\r\n    },\r\n    // @ts-expect-error wrong types\r\n    options(options) {\r\n      ctx.options = options;\r\n      return proxy;\r\n    },\r\n    processor(processor) {\r\n      ctx.processor = processor;\r\n      return ctx;\r\n    },\r\n    // @ts-expect-error wrong types\r\n    sandboxedJob() {\r\n      ctx.isSandboxed = true;\r\n      return proxy;\r\n    },\r\n    upsertJobScheduler(...args) {\r\n      ctx.jobSchedulers.push(args);\r\n      return proxy;\r\n    },\r\n  };\r\n\r\n  const proxy = new Proxy(workerHandler, {\r\n    get(target, p, receiver) {\r\n      return Reflect.get(target, p, receiver);\r\n    },\r\n  });\r\n\r\n  return workerHandler;\r\n}\r\n","import { TSchema, TObject, Static } from \"@sinclair/typebox\";\r\nimport {\r\n  RouteShorthandOptions,\r\n  HTTPMethods,\r\n  FastifyRequest,\r\n  FastifyReply,\r\n} from \"fastify\";\r\nimport { HandlerOpts } from \"./controller\";\r\nimport { ServiceContainer } from \"./service\";\r\n\r\nexport type RouteCtx = {\r\n  body?: TSchema;\r\n  output?: TSchema;\r\n  querystring?: TObject;\r\n  opts?: RouteShorthandOptions;\r\n  params?: TObject;\r\n  handler: (opts: HandlerOpts) => Promise<unknown>;\r\n};\r\n\r\nexport interface RouteC<\r\n  Omitter extends string,\r\n  Body,\r\n  Output,\r\n  QueryString,\r\n  Params,\r\n  Context,\r\n  Method extends HTTPMethods\r\n> {\r\n  body: <B extends TSchema>(\r\n    body: B\r\n  ) => Omit<\r\n    RouteC<\"body\" | Omitter, B, Output, QueryString, Params, Context, Method>,\r\n    \"body\" | Omitter\r\n  >;\r\n  output: <O extends TSchema>(\r\n    output: O\r\n  ) => Omit<\r\n    RouteC<\"output\" | Omitter, Body, O, QueryString, Params, Context, Method>,\r\n    \"output\" | Omitter\r\n  >;\r\n  querystring: <Q extends TObject>(\r\n    querystring: Q\r\n  ) => Omit<\r\n    RouteC<\"querystring\" | Omitter, Body, Output, Q, Params, Context, Method>,\r\n    \"querystring\" | Omitter\r\n  >;\r\n  handler: (\r\n    fn: (\r\n      opts: {\r\n        request: FastifyRequest;\r\n        reply: FastifyReply;\r\n        ctx: Context;\r\n        services: ServiceContainer;\r\n      } & (QueryString extends TSchema\r\n        ? { querystring: Static<QueryString> }\r\n        : void) &\r\n        (Params extends TSchema ? { params: Static<Params> } : void) &\r\n        (Method extends \"GET\" | \"HEAD\"\r\n          ? void\r\n          : { body: Body extends TSchema ? Static<Body> : void })\r\n    ) => Promise<Output extends TSchema ? Static<Output> : void>,\r\n    opts?: RouteShorthandOptions\r\n  ) => RouteCtx;\r\n  params: <P extends TObject>(\r\n    params: P\r\n  ) => Omit<\r\n    RouteC<\"params\" | Omitter, Body, Output, QueryString, P, Context, Method>,\r\n    \"params\" | Omitter\r\n  >;\r\n}\r\n\r\nexport function createRoute<\r\n  Omitter extends string,\r\n  Body,\r\n  Output,\r\n  QueryString,\r\n  Params,\r\n  Context,\r\n  Method extends HTTPMethods\r\n>(\r\n  ctx: RouteCtx\r\n): RouteC<Omitter, Body, Output, QueryString, Params, Context, Method> {\r\n  const routerHandler: RouteC<\r\n    Omitter,\r\n    Body,\r\n    Output,\r\n    QueryString,\r\n    Params,\r\n    Context,\r\n    Method\r\n  > = {\r\n    // @ts-expect-error wrong types\r\n    body(body) {\r\n      ctx.body = body;\r\n      return proxy;\r\n    },\r\n    // @ts-expect-error wrong types\r\n    output(output) {\r\n      ctx.output = output;\r\n      return proxy;\r\n    },\r\n    // @ts-expect-error wrong types\r\n    params(params) {\r\n      ctx.params = params;\r\n      return proxy;\r\n    },\r\n    // @ts-expect-error wrong types\r\n    querystring(querystring) {\r\n      ctx.querystring = querystring;\r\n      return proxy;\r\n    },\r\n    // @ts-expect-error wrong types\r\n    handler(handler: (...args: any[]) => any, opts: RouteShorthandOptions) {\r\n      ctx.handler = handler;\r\n      ctx.opts = opts;\r\n      return ctx;\r\n    },\r\n  };\r\n\r\n  const proxy = new Proxy(routerHandler, {\r\n    get(target, p, receiver) {\r\n      return Reflect.get(target, p, receiver);\r\n    },\r\n  });\r\n\r\n  return routerHandler;\r\n}\r\n","import { FastifyReply, FastifyRequest } from \"fastify\";\r\nimport { createMiddleware } from \"./middleware\";\r\nimport { createRoute, RouteC, RouteCtx } from \"./route\";\r\nimport { ServiceContainer, ServiceRegistry } from \"./service\";\r\nimport { QueueContainer, WorkerContainer } from \"./worker\";\r\n\r\nexport type HTTPMethods =\r\n  | \"SSE\"\r\n  | \"GET\"\r\n  | \"HEAD\"\r\n  | \"POST\"\r\n  | \"DELETE\"\r\n  | \"PUT\"\r\n  | \"PATCH\";\r\n\r\nexport type HandlerOpts = {\r\n  request: FastifyRequest;\r\n  reply: FastifyReply;\r\n  body?: unknown;\r\n  params?: unknown;\r\n  querystring?: unknown;\r\n  ctx: unknown;\r\n  services: ServiceContainer;\r\n  workers: WorkerContainer;\r\n  queues: QueueContainer;\r\n};\r\n\r\nexport type ControllerCtx = {\r\n  rootPath: string;\r\n  routes: Record<string, Record<string, RouteCtx>>;\r\n  middlewares: ((\r\n    opts: { ctx: unknown; request: FastifyRequest; reply: FastifyReply },\r\n    next: (opts: { ctx: unknown }) => Promise<void>\r\n  ) => Promise<unknown>)[];\r\n};\r\n\r\ninterface ControllerC<Context extends Record<string, unknown>> {\r\n  rootPath: (\r\n    rootPath: `/${string}`\r\n  ) => Pick<ControllerC<Context>, \"addRoute\" | \"finish\">;\r\n  use: <\r\n    NewContext extends Record<string, unknown>,\r\n    NextContext extends NewContext\r\n  >(\r\n    fn: ReturnType<typeof createMiddleware<NewContext, NextContext, Context>>\r\n  ) => Pick<ControllerC<NextContext>, \"use\" | \"rootPath\">;\r\n  addRoute: <M extends HTTPMethods>(\r\n    method: M,\r\n    path: `/${string}`\r\n  ) => Omit<\r\n    RouteC<\r\n      M extends \"GET\" | \"HEAD\" ? \"body\" : \"\",\r\n      unknown,\r\n      unknown,\r\n      unknown,\r\n      unknown,\r\n      Context,\r\n      M\r\n    >,\r\n    M extends \"GET\" | \"HEAD\" ? \"body\" : \"\"\r\n  >;\r\n  /**\r\n   * DO NOT CALL THIS MANUALLY!\r\n   * @returns\r\n   */\r\n  finish: (serviceRegistry: ServiceRegistry) => ControllerCtx;\r\n}\r\n\r\nexport function createController<\r\n  Context extends Record<string, unknown> = {}\r\n>(): ControllerC<Context> {\r\n  const ctx: ControllerCtx = {\r\n    rootPath: \"\",\r\n    middlewares: [],\r\n    routes: {},\r\n  };\r\n\r\n  const routerHandler: ControllerC<Context> = {\r\n    rootPath(rootPath: string) {\r\n      ctx.rootPath = rootPath;\r\n\r\n      return proxy;\r\n    },\r\n    // @ts-expect-error wrong types\r\n    addRoute<M extends HTTPMethods>(method: M, path: string) {\r\n      if (ctx.routes[method]?.[path])\r\n        throw new Error(\r\n          `${method} Route \"${ctx.rootPath}${path}\" already registered.`\r\n        );\r\n      if (!ctx.routes[method]) ctx.routes[method] = {};\r\n      ctx.routes[method][path] = {\r\n        handler: async () => {\r\n          throw new Error(\"Not implemented!\");\r\n        },\r\n      };\r\n\r\n      return createRoute<\"\", unknown, unknown, unknown, unknown, Context, M>(\r\n        ctx.routes[method][path]\r\n      );\r\n    },\r\n    // @ts-expect-error wrong types\r\n    use(fn) {\r\n      // @ts-expect-error wrong types\r\n      ctx.middlewares.push(fn);\r\n      return proxy;\r\n    },\r\n    finish() {\r\n      return ctx;\r\n    },\r\n  };\r\n\r\n  const proxy = new Proxy(routerHandler, {\r\n    get(target, p, receiver) {\r\n      return Reflect.get(target, p, receiver);\r\n    },\r\n  });\r\n\r\n  return routerHandler;\r\n}\r\n\r\nexport class ControllerRegistry {\r\n  controllers = new Map<string, ControllerCtx>();\r\n  private readonly serviceRegistry: ServiceRegistry;\r\n\r\n  constructor(serviceRegistry: ServiceRegistry) {\r\n    this.serviceRegistry = serviceRegistry;\r\n  }\r\n\r\n  register(controller: Pick<ControllerC<{}>, \"finish\">) {\r\n    const controllerCtx = controller.finish(this.serviceRegistry);\r\n\r\n    if (this.controllers.has(controllerCtx.rootPath))\r\n      throw new Error(\r\n        `Controller with rootPath \"${controllerCtx.rootPath}\" already registered.`\r\n      );\r\n\r\n    this.controllers.set(controllerCtx.rootPath, controllerCtx);\r\n  }\r\n}\r\n","import { AsyncLocalStorage } from \"async_hooks\";\r\nimport { FastifyReply, FastifyRequest } from \"fastify\";\r\n\r\nconst contextLocalStorage = new AsyncLocalStorage<{\r\n  request: FastifyRequest;\r\n  reply: FastifyReply;\r\n}>();\r\n\r\nexport function getRequestContext() {\r\n  const store = contextLocalStorage.getStore();\r\n  if (!store)\r\n    throw new Error(\r\n      \"No context set, are you trying to access the context outside of a service function?\"\r\n    );\r\n\r\n  return store;\r\n}\r\n\r\nexport function setRequestContext(ctx: {\r\n  request: FastifyRequest;\r\n  reply: FastifyReply;\r\n}) {\r\n  return contextLocalStorage.enterWith(ctx);\r\n}\r\n","import { FastifyReply, FastifyRequest } from \"fastify\";\r\nimport { getRequestContext } from \"./context\";\r\nimport { QueueContainer, WorkerContainer, WorkerRegistry } from \"./worker\";\r\n\r\ntype ServiceScope = \"REQUEST\" | \"SINGLETON\";\r\n\r\ntype ServiceFactory<T, S extends ServiceScope> = (\r\n  opts: S extends \"SINGLETON\"\r\n    ? {\r\n        services: ServiceContainer;\r\n        workers: WorkerContainer;\r\n        queues: QueueContainer;\r\n      }\r\n    : {\r\n        services: ServiceContainer;\r\n        request: FastifyRequest;\r\n        reply: FastifyReply;\r\n        workers: WorkerContainer;\r\n        queues: QueueContainer;\r\n      }\r\n) => Promise<T>;\r\ntype Service<T, S extends ServiceScope> = {\r\n  name: string;\r\n  factory: ServiceFactory<T, S>;\r\n  scope: ServiceScope;\r\n};\r\nexport type ServiceContainer = {\r\n  get<T>(name: string): Promise<T>;\r\n};\r\n\r\nexport type InferService<S> = S extends {\r\n  name: string;\r\n  factory: ServiceFactory<infer T, infer S>;\r\n}\r\n  ? T\r\n  : never;\r\n\r\nexport class ServiceRegistry {\r\n  private readonly factories = new Map<\r\n    string,\r\n    { factory: ServiceFactory<any, any>; scope: ServiceScope }\r\n  >();\r\n  private readonly singletonInstances = new Map<string, any>();\r\n  private readonly workerRegistryRef: { current: WorkerRegistry | null };\r\n\r\n  constructor(workerRegistryRef: { current: WorkerRegistry | null }) {\r\n    this.workerRegistryRef = workerRegistryRef;\r\n  }\r\n\r\n  register<T, S extends ServiceScope>({\r\n    name,\r\n    factory,\r\n    scope,\r\n  }: Service<T, S>): void {\r\n    if (this.factories.has(name)) {\r\n      throw new Error(`Service \"${name}\" already registered.`);\r\n    }\r\n    this.factories.set(name, { factory, scope });\r\n  }\r\n\r\n  resolve(): ServiceContainer {\r\n    const requestScopedInstances = new Map<string, any>();\r\n    const resolving = new Set<string>();\r\n\r\n    const container: ServiceContainer = {\r\n      get: async <T>(name: string): Promise<T> => {\r\n        if (!this.workerRegistryRef.current)\r\n          throw new Error(\"Worker registry not registered yet!\");\r\n\r\n        const definition = this.factories.get(name);\r\n        if (!definition) {\r\n          throw new Error(`No service named \"${name}\" found!`);\r\n        }\r\n\r\n        const { factory, scope } = definition;\r\n\r\n        const cache =\r\n          scope === \"SINGLETON\"\r\n            ? this.singletonInstances\r\n            : requestScopedInstances;\r\n\r\n        if (cache.has(name)) {\r\n          return cache.get(name);\r\n        }\r\n\r\n        if (resolving.has(name)) {\r\n          throw new Error(\r\n            `Circular dependency detected while resolving \"${name}\"`\r\n          );\r\n        }\r\n\r\n        let instance: any;\r\n\r\n        resolving.add(name);\r\n        if (scope === \"REQUEST\") {\r\n          const ctx = getRequestContext();\r\n          instance = await factory({\r\n            services: container,\r\n            workers: { get: this.workerRegistryRef.current.getWorker },\r\n            queues: { get: this.workerRegistryRef.current.getQueue },\r\n            ...ctx,\r\n          });\r\n        } else {\r\n          instance = await factory({\r\n            services: container,\r\n            workers: { get: this.workerRegistryRef.current.getWorker },\r\n            queues: { get: this.workerRegistryRef.current.getQueue },\r\n          });\r\n        }\r\n        resolving.delete(name);\r\n\r\n        cache.set(name, instance);\r\n        return instance;\r\n      },\r\n    };\r\n\r\n    return container;\r\n  }\r\n}\r\n\r\nexport function createService<T, S extends ServiceScope>(\r\n  name: string,\r\n  factory: ServiceFactory<T, S>,\r\n  scope?: S\r\n) {\r\n  return { name, factory, scope: scope ?? (\"SINGLETON\" as S) };\r\n}\r\n","export function createMiddleware<\r\n  NewContext extends Record<string, unknown>,\r\n  NextContext extends NewContext,\r\n  Context extends Record<string, unknown> = {}\r\n>(\r\n  fn: (\r\n    opts: { ctx: Context },\r\n    next: (opts: { ctx: NewContext }) => Promise<void>\r\n  ) => Promise<NextContext>\r\n) {\r\n  return fn;\r\n}\r\n"]}