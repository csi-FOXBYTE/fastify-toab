{"version":3,"sources":["../src/worker.ts","../src/route.ts","../src/controller.ts","../src/context.ts","../src/service.ts","../src/middleware.ts"],"names":["WorkerRegistry","serviceRegistry","workerCtx","queue","Queue","jobScheduler","worker","Worker","job","token","onHandler","onceHandler","name","createWorker","ctx","workerHandler","queueName","queueOptions","proxy","connection","args","options","processor","target","p","receiver","createRoute","routerHandler","body","output","params","querystring","handler","opts","createController","rootPath","method","path","fn","ControllerRegistry","controller","controllerCtx","contextLocalStorage","AsyncLocalStorage","getRequestContext","store","ServiceRegistry","workerRegistryRef","factory","scope","requestScopedInstances","resolving","container","definition","cache","instance","createService","createMiddleware"],"mappings":"gHAiDaA,CAAAA,CAAN,KAAqB,CAK1B,WAAA,CAAYC,CAAAA,CAAkC,CAJ9C,KAAiB,MAAA,CAAS,IAAI,GAAA,CAC9B,IAAA,CAAiB,OAAA,CAAU,IAAI,IAI7B,IAAA,CAAK,eAAA,CAAkBA,EACzB,CAEA,MAAM,QAAA,CAGJC,EAA4B,CAC5B,GAAI,IAAA,CAAK,MAAA,CAAO,GAAA,CAAIA,CAAAA,CAAU,SAAS,CAAA,CACrC,MAAM,IAAI,KAAA,CACR,CAAA,iBAAA,EAAoBA,CAAAA,CAAU,SAAS,CAAA,wBAAA,CACzC,CAAA,CAGF,IAAMC,CAAAA,CAAQ,IAAIC,KAAAA,CAAMF,EAAU,SAAA,CAAW,CAC3C,GAAGA,CAAAA,CAAU,YAAA,CACb,UAAA,CAAYA,EAAU,UACxB,CAAC,CAAA,CAED,IAAA,CAAK,MAAA,CAAO,GAAA,CAAIC,EAAM,IAAA,CAAMA,CAAK,CAAA,CAEjC,IAAA,IAAWE,CAAAA,IAAgBH,CAAAA,CAAU,cACnC,MAAMC,CAAAA,CAAM,kBAAA,CAAmB,GAAGE,CAAY,CAAA,CAGhD,GAAI,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAIH,CAAAA,CAAU,SAAS,CAAA,CACtC,MAAM,IAAI,KAAA,CACR,CAAA,iBAAA,EAAoBA,CAAAA,CAAU,SAAS,CAAA,wBAAA,CACzC,EAGF,IAAMI,CAAAA,CAAS,IAAIC,MAAAA,CACjBL,CAAAA,CAAU,SAAA,CACV,OAAOA,CAAAA,CAAU,SAAA,EAAc,UAAA,CAC3B,MAAOM,CAAAA,CAAKC,CAAAA,GAAU,CACpB,GAAI,OAAOP,CAAAA,CAAU,SAAA,EAAc,UAAA,CACjC,MAAM,IAAI,KAAA,CAAM,uBAAuB,CAAA,CAEzC,OAAOA,CAAAA,CAAU,SAAA,CACfM,EACA,CACE,QAAA,CAAU,IAAA,CAAK,eAAA,CAAgB,OAAA,EAAQ,CACvC,QAAS,CACP,GAAA,CAAK,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,IAAI,CAC/B,CAAA,CACA,MAAA,CAAQ,CACN,GAAA,CAAK,IAAA,CAAK,QAAA,CAAS,KAAK,IAAI,CAC9B,CACF,CAAA,CACAC,CACF,CACF,EACAP,CAAAA,CAAU,SAAA,CACd,CAAE,GAAGA,CAAAA,CAAU,OAAA,CAAS,WAAYA,CAAAA,CAAU,UAAW,CAC3D,CAAA,CAEA,IAAA,IAAWQ,CAAAA,IAAaR,EAAU,UAAA,CAChCI,CAAAA,CAAO,EAAA,CAAG,GAAGI,CAAS,CAAA,CAGxB,QAAWC,CAAAA,IAAeT,CAAAA,CAAU,YAAA,CAClCI,CAAAA,CAAO,IAAA,CAAK,GAAGK,CAAW,CAAA,CAG5B,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAIT,CAAAA,CAAU,SAAA,CAAWI,CAAM,EAC9C,CAEA,QAAA,CAA0BM,CAAAA,CAAc,CACtC,IAAMT,EAAQ,IAAA,CAAK,MAAA,CAAO,GAAA,CAAIS,CAAI,CAAA,CAElC,GAAI,CAACT,CAAAA,CACH,MAAM,IAAI,KAAA,CAAM,CAAA,gBAAA,EAAmBS,CAAI,UAAU,CAAA,CAGnD,OAAOT,CACT,CAEA,SAAA,CAA4BS,CAAAA,CAAc,CACxC,IAAMN,CAAAA,CAAS,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAIM,CAAI,CAAA,CAEpC,GAAI,CAACN,CAAAA,CACH,MAAM,IAAI,KAAA,CAAM,CAAA,iBAAA,EAAoBM,CAAI,CAAA,QAAA,CAAU,CAAA,CAGpD,OAAON,CACT,CACF,EA2FO,SAASO,CAAAA,EAGd,CACA,IAAMC,CAAAA,CAA2B,CAC/B,SAAA,CAAW,GACX,aAAA,CAAe,EAAC,CAChB,YAAA,CAAc,EAAC,CACf,MAAO,IAAA,CACP,UAAA,CAAY,EAAC,CACb,MAAA,CAAQ,IAAA,CACR,UAAW,EAAA,CACX,UAAA,CAAY,EAAC,CACb,WAAA,CAAa,KACf,EAEMC,CAAAA,CAA4D,CAEhE,KAAA,CAAMC,CAAAA,CAAWC,CAAAA,CAAc,CAC7B,OAAAH,CAAAA,CAAI,YAAA,CAAeG,CAAAA,CACnBH,CAAAA,CAAI,SAAA,CAAYE,CAAAA,CACTE,CACT,CAAA,CACA,UAAA,CAAWC,CAAAA,CAAY,CACrB,OAAAL,CAAAA,CAAI,WAAaK,CAAAA,CACVD,CACT,CAAA,CAEA,GAAA,EAAM,CACJ,OAAAJ,EAAI,WAAA,CAAc,KAAA,CACXI,CACT,CAAA,CACA,EAAA,CAAA,GAAME,CAAAA,CAAM,CACV,OAAAN,CAAAA,CAAI,UAAA,CAAW,IAAA,CAAKM,CAAI,CAAA,CACjBF,CACT,CAAA,CACA,IAAA,CAAA,GAAQE,CAAAA,CAAM,CACZ,OAAAN,CAAAA,CAAI,aAAa,IAAA,CAAKM,CAAI,CAAA,CACnBF,CACT,CAAA,CAEA,OAAA,CAAQG,EAAS,CACf,OAAAP,CAAAA,CAAI,OAAA,CAAUO,CAAAA,CACPH,CACT,EACA,SAAA,CAAUI,CAAAA,CAAW,CACnB,OAAAR,CAAAA,CAAI,SAAA,CAAYQ,EACTR,CACT,CAAA,CAEA,YAAA,EAAe,CACb,OAAAA,CAAAA,CAAI,YAAc,IAAA,CACXI,CACT,CAAA,CACA,kBAAA,CAAA,GAAsBE,CAAAA,CAAM,CAC1B,OAAAN,CAAAA,CAAI,aAAA,CAAc,IAAA,CAAKM,CAAI,CAAA,CACpBF,CACT,CACF,CAAA,CAEMA,CAAAA,CAAQ,IAAI,KAAA,CAAMH,CAAAA,CAAe,CACrC,IAAIQ,CAAAA,CAAQC,CAAAA,CAAGC,CAAAA,CAAU,CACvB,OAAO,OAAA,CAAQ,IAAIF,CAAAA,CAAQC,CAAAA,CAAGC,CAAQ,CACxC,CACF,CAAC,EAED,OAAOV,CACT,CCnOO,SAASW,CAAAA,CASdZ,CAAAA,CACqE,CACrE,IAAMa,CAAAA,CAQF,CAEF,IAAA,CAAKC,CAAAA,CAAM,CACT,OAAAd,CAAAA,CAAI,IAAA,CAAOc,CAAAA,CACJV,CACT,CAAA,CAEA,MAAA,CAAOW,EAAQ,CACb,OAAAf,CAAAA,CAAI,MAAA,CAASe,CAAAA,CACNX,CACT,EAEA,MAAA,CAAOY,CAAAA,CAAQ,CACb,OAAAhB,CAAAA,CAAI,MAAA,CAASgB,EACNZ,CACT,CAAA,CAEA,WAAA,CAAYa,CAAAA,CAAa,CACvB,OAAAjB,EAAI,WAAA,CAAciB,CAAAA,CACXb,CACT,CAAA,CAEA,OAAA,CAAQc,CAAAA,CAAkCC,EAA6B,CACrE,OAAAnB,CAAAA,CAAI,OAAA,CAAUkB,CAAAA,CACdlB,CAAAA,CAAI,KAAOmB,CAAAA,CACJnB,CACT,CACF,CAAA,CAEMI,CAAAA,CAAQ,IAAI,MAAMS,CAAAA,CAAe,CACrC,GAAA,CAAIJ,CAAAA,CAAQC,CAAAA,CAAGC,CAAAA,CAAU,CACvB,OAAO,OAAA,CAAQ,GAAA,CAAIF,CAAAA,CAAQC,CAAAA,CAAGC,CAAQ,CACxC,CACF,CAAC,CAAA,CAED,OAAOE,CACT,CC1DO,SAASO,GAEU,CACxB,IAAMpB,CAAAA,CAAqB,CACzB,QAAA,CAAU,EAAA,CACV,YAAa,EAAC,CACd,MAAA,CAAQ,EACV,CAAA,CAEMa,EAAsC,CAC1C,QAAA,CAASQ,CAAAA,CAAkB,CACzB,OAAArB,CAAAA,CAAI,SAAWqB,CAAAA,CAERjB,CACT,CAAA,CAEA,QAAA,CAAgCkB,CAAAA,CAAWC,CAAAA,CAAc,CACvD,GAAIvB,CAAAA,CAAI,MAAA,CAAOsB,CAAM,CAAA,GAAIC,CAAI,EAC3B,MAAM,IAAI,KAAA,CACR,CAAA,EAAGD,CAAM,CAAA,QAAA,EAAWtB,EAAI,QAAQ,CAAA,EAAGuB,CAAI,CAAA,qBAAA,CACzC,CAAA,CACF,OAAKvB,EAAI,MAAA,CAAOsB,CAAM,CAAA,GAAGtB,CAAAA,CAAI,MAAA,CAAOsB,CAAM,EAAI,EAAC,CAAA,CAC/CtB,CAAAA,CAAI,MAAA,CAAOsB,CAAM,CAAA,CAAEC,CAAI,CAAA,CAAI,CACzB,OAAA,CAAS,SAAY,CACnB,MAAM,IAAI,KAAA,CAAM,kBAAkB,CACpC,CACF,CAAA,CAEOX,CAAAA,CACLZ,EAAI,MAAA,CAAOsB,CAAM,CAAA,CAAEC,CAAI,CACzB,CACF,EAEA,GAAA,CAAIC,CAAAA,CAAI,CAEN,OAAAxB,CAAAA,CAAI,WAAA,CAAY,KAAKwB,CAAE,CAAA,CAChBpB,CACT,CAAA,CACA,MAAA,EAAS,CACP,OAAOJ,CACT,CACF,CAAA,CAEMI,CAAAA,CAAQ,IAAI,KAAA,CAAMS,EAAe,CACrC,GAAA,CAAIJ,CAAAA,CAAQC,CAAAA,CAAGC,CAAAA,CAAU,CACvB,OAAO,OAAA,CAAQ,GAAA,CAAIF,CAAAA,CAAQC,CAAAA,CAAGC,CAAQ,CACxC,CACF,CAAC,CAAA,CAED,OAAOE,CACT,CAEO,IAAMY,EAAN,KAAyB,CAI9B,WAAA,CAAYtC,CAAAA,CAAkC,CAH9C,IAAA,CAAA,WAAA,CAAc,IAAI,GAAA,CAIhB,IAAA,CAAK,eAAA,CAAkBA,EACzB,CAEA,QAAA,CAASuC,EAA6C,CACpD,IAAMC,CAAAA,CAAgBD,CAAAA,CAAW,MAAA,CAAO,IAAA,CAAK,eAAe,CAAA,CAE5D,GAAI,IAAA,CAAK,WAAA,CAAY,GAAA,CAAIC,CAAAA,CAAc,QAAQ,CAAA,CAC7C,MAAM,IAAI,KAAA,CACR,CAAA,0BAAA,EAA6BA,CAAAA,CAAc,QAAQ,CAAA,qBAAA,CACrD,CAAA,CAEF,IAAA,CAAK,WAAA,CAAY,GAAA,CAAIA,CAAAA,CAAc,SAAUA,CAAa,EAC5D,CACF,ECvIA,IAAMC,CAAAA,CAAsB,IAAIC,iBAAAA,CAKzB,SAASC,GAAoB,CAClC,IAAMC,CAAAA,CAAQH,CAAAA,CAAoB,QAAA,EAAS,CAC3C,GAAI,CAACG,CAAAA,CACH,MAAM,IAAI,KAAA,CACR,qFACF,EAEF,OAAOA,CACT,CCqBO,IAAMC,CAAAA,CAAN,KAAsB,CAQ3B,WAAA,CAAYC,CAAAA,CAAuD,CAPnE,IAAA,CAAiB,SAAA,CAAY,IAAI,GAAA,CAIjC,IAAA,CAAiB,kBAAA,CAAqB,IAAI,GAAA,CAIxC,IAAA,CAAK,iBAAA,CAAoBA,EAC3B,CAEA,QAAA,CAAoC,CAClC,IAAA,CAAAnC,CAAAA,CACA,OAAA,CAAAoC,CAAAA,CACA,MAAAC,CACF,CAAA,CAAwB,CACtB,GAAI,IAAA,CAAK,SAAA,CAAU,IAAIrC,CAAI,CAAA,CACzB,MAAM,IAAI,KAAA,CAAM,CAAA,SAAA,EAAYA,CAAI,CAAA,qBAAA,CAAuB,CAAA,CAEzD,IAAA,CAAK,SAAA,CAAU,GAAA,CAAIA,CAAAA,CAAM,CAAE,OAAA,CAAAoC,CAAAA,CAAS,KAAA,CAAAC,CAAM,CAAC,EAC7C,CAEA,OAAA,EAA4B,CAC1B,IAAMC,CAAAA,CAAyB,IAAI,GAAA,CAC7BC,EAAY,IAAI,GAAA,CAEhBC,CAAAA,CAA8B,CAClC,GAAA,CAAK,MAAUxC,GAA6B,CAC1C,GAAI,CAAC,IAAA,CAAK,iBAAA,CAAkB,OAAA,CAC1B,MAAM,IAAI,KAAA,CAAM,qCAAqC,CAAA,CAEvD,IAAMyC,CAAAA,CAAa,KAAK,SAAA,CAAU,GAAA,CAAIzC,CAAI,CAAA,CAC1C,GAAI,CAACyC,EACH,MAAM,IAAI,KAAA,CAAM,CAAA,kBAAA,EAAqBzC,CAAI,CAAA,QAAA,CAAU,EAGrD,GAAM,CAAE,OAAA,CAAAoC,CAAAA,CAAS,KAAA,CAAAC,CAAM,EAAII,CAAAA,CAErBC,CAAAA,CACJL,CAAAA,GAAU,WAAA,CACN,IAAA,CAAK,kBAAA,CACLC,EAEN,GAAII,CAAAA,CAAM,GAAA,CAAI1C,CAAI,CAAA,CAChB,OAAO0C,EAAM,GAAA,CAAI1C,CAAI,CAAA,CAGvB,GAAIuC,CAAAA,CAAU,GAAA,CAAIvC,CAAI,CAAA,CACpB,MAAM,IAAI,KAAA,CACR,CAAA,8CAAA,EAAiDA,CAAI,CAAA,CAAA,CACvD,EAGF,IAAI2C,CAAAA,CAGJ,GADAJ,CAAAA,CAAU,GAAA,CAAIvC,CAAI,EACdqC,CAAAA,GAAU,SAAA,CAAW,CACvB,IAAMnC,CAAAA,CAAM8B,CAAAA,GACZW,CAAAA,CAAW,MAAMP,CAAAA,CAAQ,CACvB,QAAA,CAAUI,CAAAA,CACV,QAAS,CAAE,GAAA,CAAK,IAAA,CAAK,iBAAA,CAAkB,OAAA,CAAQ,SAAU,EACzD,MAAA,CAAQ,CAAE,GAAA,CAAK,IAAA,CAAK,iBAAA,CAAkB,OAAA,CAAQ,QAAS,CAAA,CACvD,GAAGtC,CACL,CAAC,EACH,CAAA,KACEyC,EAAW,MAAMP,CAAAA,CAAQ,CACvB,QAAA,CAAUI,CAAAA,CACV,OAAA,CAAS,CAAE,GAAA,CAAK,IAAA,CAAK,iBAAA,CAAkB,OAAA,CAAQ,SAAU,CAAA,CACzD,OAAQ,CAAE,GAAA,CAAK,IAAA,CAAK,iBAAA,CAAkB,OAAA,CAAQ,QAAS,CACzD,CAAC,CAAA,CAEH,OAAAD,CAAAA,CAAU,MAAA,CAAOvC,CAAI,EAErB0C,CAAAA,CAAM,GAAA,CAAI1C,CAAAA,CAAM2C,CAAQ,CAAA,CACjBA,CACT,CACF,CAAA,CAEA,OAAOH,CACT,CACF,EAEO,SAASI,EACd5C,CAAAA,CACAoC,CAAAA,CACAC,CAAAA,CACA,CACA,OAAO,CAAE,KAAArC,CAAAA,CAAM,OAAA,CAAAoC,CAAAA,CAAS,KAAA,CAAOC,CAAAA,EAAU,WAAkB,CAC7D,CC9HO,SAASQ,CAAAA,CAKdnB,CAAAA,CAIA,CACA,OAAOA,CACT","file":"index.js","sourcesContent":["import {\r\n  ConnectionOptions,\r\n  Job,\r\n  JobSchedulerTemplateOptions,\r\n  Queue,\r\n  QueueOptions,\r\n  RepeatOptions,\r\n  SandboxedJob,\r\n  Worker,\r\n  WorkerListener,\r\n  WorkerOptions,\r\n} from \"bullmq\";\r\nimport { ServiceContainer, ServiceRegistry } from \"./service\";\r\n\r\nexport interface WorkerContainer {\r\n  get: WorkerRegistry[\"getWorker\"];\r\n}\r\n\r\nexport interface QueueContainer {\r\n  get: WorkerRegistry[\"getQueue\"];\r\n}\r\n\r\nexport interface WorkerCtx<Q extends Queue, W extends Worker> {\r\n  queueName: string;\r\n  queueOptions?: QueueOptions;\r\n  jobSchedulers: Parameters<\r\n    WorkerC<\"\", Job<any, any, any>, null>[\"upsertJobScheduler\"]\r\n  >[];\r\n  onHandlers: Parameters<WorkerC<\"\", Job<any, any, any>, null>[\"on\"]>[];\r\n  onceHandlers: Parameters<WorkerC<\"\", Job<any, any, any>, null>[\"on\"]>[];\r\n  isSandboxed: boolean;\r\n  connection: ConnectionOptions;\r\n  options?: WorkerOptions;\r\n  processor:\r\n    | string\r\n    | URL\r\n    | ((\r\n        job: Job<any, any, any>,\r\n        ctx: {\r\n          services: ReturnType<ServiceRegistry[\"resolve\"]>;\r\n          workers: WorkerContainer;\r\n          queues: QueueContainer;\r\n        },\r\n        token?: string\r\n      ) => Promise<any>);\r\n  queue: Q; // only type\r\n  worker: W; // only type\r\n}\r\n\r\nexport class WorkerRegistry {\r\n  private readonly queues = new Map<string, Queue>();\r\n  private readonly workers = new Map<string, Worker>();\r\n  private readonly serviceRegistry: ServiceRegistry;\r\n\r\n  constructor(serviceRegistry: ServiceRegistry) {\r\n    this.serviceRegistry = serviceRegistry;\r\n  }\r\n\r\n  async register<\r\n    Q extends Queue<any, any, any, any, any>,\r\n    W extends Worker<any, any, any>\r\n  >(workerCtx: WorkerCtx<Q, W>) {\r\n    if (this.queues.has(workerCtx.queueName)) {\r\n      throw new Error(\r\n        `Queue with name \"${workerCtx.queueName}\" is already registered.`\r\n      );\r\n    }\r\n\r\n    const queue = new Queue(workerCtx.queueName, {\r\n      ...workerCtx.queueOptions,\r\n      connection: workerCtx.connection,\r\n    });\r\n\r\n    this.queues.set(queue.name, queue);\r\n\r\n    for (const jobScheduler of workerCtx.jobSchedulers) {\r\n      await queue.upsertJobScheduler(...jobScheduler);\r\n    }\r\n\r\n    if (this.workers.has(workerCtx.queueName)) {\r\n      throw new Error(\r\n        `Queue with name \"${workerCtx.queueName}\" is already registered.`\r\n      );\r\n    }\r\n\r\n    const worker = new Worker(\r\n      workerCtx.queueName,\r\n      typeof workerCtx.processor === \"function\"\r\n        ? async (job, token) => {\r\n            if (typeof workerCtx.processor !== \"function\")\r\n              throw new Error(\"Something went wrong!\");\r\n\r\n            return workerCtx.processor(\r\n              job,\r\n              {\r\n                services: this.serviceRegistry.resolve(),\r\n                workers: {\r\n                  get: this.getWorker.bind(this),\r\n                },\r\n                queues: {\r\n                  get: this.getQueue.bind(this),\r\n                },\r\n              },\r\n              token\r\n            );\r\n          }\r\n        : workerCtx.processor,\r\n      { ...workerCtx.options, connection: workerCtx.connection }\r\n    );\r\n\r\n    for (const onHandler of workerCtx.onHandlers) {\r\n      worker.on(...onHandler);\r\n    }\r\n\r\n    for (const onceHandler of workerCtx.onceHandlers) {\r\n      worker.once(...onceHandler);\r\n    }\r\n\r\n    this.workers.set(workerCtx.queueName, worker);\r\n  }\r\n\r\n  getQueue<Q extends Queue>(name: string) {\r\n    const queue = this.queues.get(name);\r\n\r\n    if (!queue) {\r\n      throw new Error(`No queue named \"${name}\" found.`);\r\n    }\r\n\r\n    return queue as Q;\r\n  }\r\n\r\n  getWorker<W extends Worker>(name: string) {\r\n    const worker = this.workers.get(name);\r\n\r\n    if (!worker) {\r\n      throw new Error(`No Worker named \"${name}\" found.`);\r\n    }\r\n\r\n    return worker as W;\r\n  }\r\n}\r\n\r\nexport interface WorkerC<\r\n  Omitter extends string,\r\n  J extends Job<any, any, any> | null,\r\n  SJ extends SandboxedJob<any, any> | null\r\n> {\r\n  queue: (\r\n    queueName: string,\r\n    queueOptions?: QueueOptions\r\n  ) => Pick<WorkerC<Omitter | \"queue\" | \"processor\", J, SJ>, \"sandboxedJob\" | \"job\">;\r\n  job<NewJob extends Job<any, any, any>>(): Omit<\r\n    WorkerC<Omitter | \"job\" | \"sandboxedJob\", NewJob, SJ>,\r\n    Omitter | \"job\" | \"sandboxedJob\"\r\n  >;\r\n  sandboxedJob<NewSandboxedJob extends SandboxedJob<any, any>>(): Omit<\r\n    WorkerC<Omitter | \"sandboxedJob\" | \"job\", J, NewSandboxedJob>,\r\n    Omitter | \"sandboxedJob\" | \"job\"\r\n  >;\r\n  options: (\r\n    options: WorkerOptions\r\n  ) => Omit<WorkerC<Omitter | \"options\", J, SJ>, Omitter | \"options\">;\r\n  connection: (\r\n    connection: ConnectionOptions\r\n  ) => Pick<WorkerC<Omitter | \"connection\", J, SJ>, \"processor\">;\r\n  processor: J extends Job<infer T, infer R, infer N>\r\n    ? (\r\n        processor: (\r\n          job: Job<T, R, N>,\r\n          ctx: {\r\n            services: ServiceContainer;\r\n            workers: {\r\n              get: WorkerRegistry[\"getWorker\"];\r\n            };\r\n            queues: {\r\n              get: WorkerRegistry[\"getQueue\"];\r\n            };\r\n          },\r\n          token?: string\r\n        ) => Promise<R>\r\n      ) => WorkerCtx<Queue<T, R, N>, Worker<T, R, string>>\r\n    : SJ extends SandboxedJob<infer T, infer R>\r\n    ? (\r\n        url: string | URL\r\n      ) => WorkerCtx<Queue<T, R, string>, Worker<T, R, string>>\r\n    : never;\r\n  upsertJobScheduler: J extends Job<infer T, infer R, infer N>\r\n    ? (\r\n        jobSchedulerId: string,\r\n        repeatOpts: Omit<RepeatOptions, \"key\">,\r\n        jobTemplate?: {\r\n          name?: N;\r\n          data?: T;\r\n          opts?: JobSchedulerTemplateOptions;\r\n        }\r\n      ) => Omit<WorkerC<Omitter, J, SJ>, Omitter>\r\n    : SJ extends SandboxedJob<infer T>\r\n    ? (\r\n        jobSchedulerId: string,\r\n        repeatOpts: Omit<RepeatOptions, \"key\">,\r\n        jobTemplate?: {\r\n          name?: string;\r\n          data?: T;\r\n          opts?: JobSchedulerTemplateOptions;\r\n        }\r\n      ) => Omit<WorkerC<Omitter, J, SJ>, Omitter>\r\n    : never;\r\n  on: J extends Job<any, any, any>\r\n    ? <Key extends keyof WorkerListener<J>>(\r\n        event: Key,\r\n        listener: WorkerListener<J>[Key]\r\n      ) => Omit<WorkerC<Omitter, J, SJ>, Omitter>\r\n    : SJ extends SandboxedJob<infer T, infer R>\r\n    ? <Key extends keyof WorkerListener<Job<T, R, string>>>(\r\n        event: Key,\r\n        listener: WorkerListener<Job<T, R, string>>[Key]\r\n      ) => Omit<WorkerC<Omitter, J, SJ>, Omitter>\r\n    : never;\r\n  once: J extends Job<any, any, any>\r\n    ? <Key extends keyof WorkerListener<J>>(\r\n        event: Key,\r\n        listener: WorkerListener<J>[Key]\r\n      ) => Omit<WorkerC<Omitter, J, SJ>, Omitter>\r\n    : SJ extends SandboxedJob<infer T, infer R>\r\n    ? <Key extends keyof WorkerListener<Job<T, R, string>>>(\r\n        event: Key,\r\n        listener: WorkerListener<Job<T, R, string>>[Key]\r\n      ) => Omit<WorkerC<Omitter, J, SJ>, Omitter>\r\n    : never;\r\n}\r\n\r\nexport function createWorker<Omitter extends string = \"\">(): Pick<\r\n  WorkerC<Omitter, null, null>,\r\n  \"queue\"\r\n> {\r\n  const ctx: WorkerCtx<any, any> = {\r\n    queueName: \"\",\r\n    jobSchedulers: [],\r\n    onceHandlers: [],\r\n    queue: null,\r\n    connection: {},\r\n    worker: null,\r\n    processor: \"\",\r\n    onHandlers: [],\r\n    isSandboxed: false,\r\n  };\r\n\r\n  const workerHandler: WorkerC<Omitter, Job<any, any, any>, null> = {\r\n    // @ts-expect-error wrong types\r\n    queue(queueName, queueOptions) {\r\n      ctx.queueOptions = queueOptions;\r\n      ctx.queueName = queueName;\r\n      return proxy;\r\n    },\r\n    connection(connection) {\r\n      ctx.connection = connection;\r\n      return proxy;\r\n    },\r\n    // @ts-expect-error wrong types\r\n    job() {\r\n      ctx.isSandboxed = false;\r\n      return proxy;\r\n    },\r\n    on(...args) {\r\n      ctx.onHandlers.push(args);\r\n      return proxy;\r\n    },\r\n    once(...args) {\r\n      ctx.onceHandlers.push(args);\r\n      return proxy;\r\n    },\r\n    // @ts-expect-error wrong types\r\n    options(options) {\r\n      ctx.options = options;\r\n      return proxy;\r\n    },\r\n    processor(processor) {\r\n      ctx.processor = processor;\r\n      return ctx;\r\n    },\r\n    // @ts-expect-error wrong types\r\n    sandboxedJob() {\r\n      ctx.isSandboxed = true;\r\n      return proxy;\r\n    },\r\n    upsertJobScheduler(...args) {\r\n      ctx.jobSchedulers.push(args);\r\n      return proxy;\r\n    },\r\n  };\r\n\r\n  const proxy = new Proxy(workerHandler, {\r\n    get(target, p, receiver) {\r\n      return Reflect.get(target, p, receiver);\r\n    },\r\n  });\r\n\r\n  return workerHandler;\r\n}\r\n","import { TSchema, TObject, Static } from \"@sinclair/typebox\";\r\nimport {\r\n  RouteShorthandOptions,\r\n  HTTPMethods,\r\n  FastifyRequest,\r\n  FastifyReply,\r\n} from \"fastify\";\r\nimport { HandlerOpts } from \"./controller\";\r\nimport { ServiceContainer } from \"./service\";\r\n\r\nexport type RouteCtx = {\r\n  body?: TSchema;\r\n  output?: TSchema;\r\n  querystring?: TObject;\r\n  opts?: RouteShorthandOptions;\r\n  params?: TObject;\r\n  handler: (opts: HandlerOpts) => Promise<unknown>;\r\n};\r\n\r\nexport interface RouteC<\r\n  Omitter extends string,\r\n  Body,\r\n  Output,\r\n  QueryString,\r\n  Params,\r\n  Context,\r\n  Method extends HTTPMethods\r\n> {\r\n  body: <B extends TSchema>(\r\n    body: B\r\n  ) => Omit<\r\n    RouteC<\"body\" | Omitter, B, Output, QueryString, Params, Context, Method>,\r\n    \"body\" | Omitter\r\n  >;\r\n  output: <O extends TSchema>(\r\n    output: O\r\n  ) => Omit<\r\n    RouteC<\"output\" | Omitter, Body, O, QueryString, Params, Context, Method>,\r\n    \"output\" | Omitter\r\n  >;\r\n  querystring: <Q extends TObject>(\r\n    querystring: Q\r\n  ) => Omit<\r\n    RouteC<\"querystring\" | Omitter, Body, Output, Q, Params, Context, Method>,\r\n    \"querystring\" | Omitter\r\n  >;\r\n  handler: (\r\n    fn: (\r\n      opts: {\r\n        request: FastifyRequest;\r\n        reply: FastifyReply;\r\n        ctx: Context;\r\n        services: ServiceContainer;\r\n      } & (QueryString extends TSchema\r\n        ? { querystring: Static<QueryString> }\r\n        : void) &\r\n        (Params extends TSchema ? { params: Static<Params> } : void) &\r\n        (Method extends \"GET\" | \"HEAD\"\r\n          ? void\r\n          : { body: Body extends TSchema ? Static<Body> : void })\r\n    ) => Promise<Output extends TSchema ? Static<Output> : void>,\r\n    opts?: RouteShorthandOptions\r\n  ) => RouteCtx;\r\n  params: <P extends TObject>(\r\n    params: P\r\n  ) => Omit<\r\n    RouteC<\"params\" | Omitter, Body, Output, QueryString, P, Context, Method>,\r\n    \"params\" | Omitter\r\n  >;\r\n}\r\n\r\nexport function createRoute<\r\n  Omitter extends string,\r\n  Body,\r\n  Output,\r\n  QueryString,\r\n  Params,\r\n  Context,\r\n  Method extends HTTPMethods\r\n>(\r\n  ctx: RouteCtx\r\n): RouteC<Omitter, Body, Output, QueryString, Params, Context, Method> {\r\n  const routerHandler: RouteC<\r\n    Omitter,\r\n    Body,\r\n    Output,\r\n    QueryString,\r\n    Params,\r\n    Context,\r\n    Method\r\n  > = {\r\n    // @ts-expect-error wrong types\r\n    body(body) {\r\n      ctx.body = body;\r\n      return proxy;\r\n    },\r\n    // @ts-expect-error wrong types\r\n    output(output) {\r\n      ctx.output = output;\r\n      return proxy;\r\n    },\r\n    // @ts-expect-error wrong types\r\n    params(params) {\r\n      ctx.params = params;\r\n      return proxy;\r\n    },\r\n    // @ts-expect-error wrong types\r\n    querystring(querystring) {\r\n      ctx.querystring = querystring;\r\n      return proxy;\r\n    },\r\n    // @ts-expect-error wrong types\r\n    handler(handler: (...args: any[]) => any, opts: RouteShorthandOptions) {\r\n      ctx.handler = handler;\r\n      ctx.opts = opts;\r\n      return ctx;\r\n    },\r\n  };\r\n\r\n  const proxy = new Proxy(routerHandler, {\r\n    get(target, p, receiver) {\r\n      return Reflect.get(target, p, receiver);\r\n    },\r\n  });\r\n\r\n  return routerHandler;\r\n}\r\n","import { FastifyReply, FastifyRequest } from \"fastify\";\r\nimport { createMiddleware } from \"./middleware\";\r\nimport { createRoute, RouteC, RouteCtx } from \"./route\";\r\nimport { ServiceContainer, ServiceRegistry } from \"./service\";\r\nimport { QueueContainer, WorkerContainer } from \"./worker\";\r\n\r\nexport type HTTPMethods =\r\n  | \"SSE\"\r\n  | \"GET\"\r\n  | \"HEAD\"\r\n  | \"POST\"\r\n  | \"DELETE\"\r\n  | \"PUT\"\r\n  | \"PATCH\";\r\n\r\nexport type HandlerOpts = {\r\n  request: FastifyRequest;\r\n  reply: FastifyReply;\r\n  body?: unknown;\r\n  params?: unknown;\r\n  querystring?: unknown;\r\n  ctx: unknown;\r\n  services: ServiceContainer;\r\n  workers: WorkerContainer;\r\n  queues: QueueContainer;\r\n};\r\n\r\nexport type ControllerCtx = {\r\n  rootPath: string;\r\n  routes: Record<string, Record<string, RouteCtx>>;\r\n  middlewares: ((\r\n    opts: { ctx: unknown; request: FastifyRequest; reply: FastifyReply },\r\n    next: (opts: { ctx: unknown }) => Promise<void>\r\n  ) => Promise<unknown>)[];\r\n};\r\n\r\ninterface ControllerC<Context extends Record<string, unknown>> {\r\n  rootPath: (\r\n    rootPath: `/${string}`\r\n  ) => Pick<ControllerC<Context>, \"addRoute\" | \"finish\">;\r\n  use: <\r\n    NewContext extends Record<string, unknown>,\r\n    NextContext extends NewContext\r\n  >(\r\n    fn: ReturnType<typeof createMiddleware<NewContext, NextContext, Context>>\r\n  ) => Pick<ControllerC<NextContext>, \"use\" | \"rootPath\">;\r\n  addRoute: <M extends HTTPMethods>(\r\n    method: M,\r\n    path: `/${string}`\r\n  ) => Omit<\r\n    RouteC<\r\n      M extends \"GET\" | \"HEAD\" ? \"body\" : \"\",\r\n      unknown,\r\n      unknown,\r\n      unknown,\r\n      unknown,\r\n      Context,\r\n      M\r\n    >,\r\n    M extends \"GET\" | \"HEAD\" ? \"body\" : \"\"\r\n  >;\r\n  /**\r\n   * DO NOT CALL THIS MANUALLY!\r\n   * @returns\r\n   */\r\n  finish: (serviceRegistry: ServiceRegistry) => ControllerCtx;\r\n}\r\n\r\nexport function createController<\r\n  Context extends Record<string, unknown> = {}\r\n>(): ControllerC<Context> {\r\n  const ctx: ControllerCtx = {\r\n    rootPath: \"\",\r\n    middlewares: [],\r\n    routes: {},\r\n  };\r\n\r\n  const routerHandler: ControllerC<Context> = {\r\n    rootPath(rootPath: string) {\r\n      ctx.rootPath = rootPath;\r\n\r\n      return proxy;\r\n    },\r\n    // @ts-expect-error wrong types\r\n    addRoute<M extends HTTPMethods>(method: M, path: string) {\r\n      if (ctx.routes[method]?.[path])\r\n        throw new Error(\r\n          `${method} Route \"${ctx.rootPath}${path}\" already registered.`\r\n        );\r\n      if (!ctx.routes[method]) ctx.routes[method] = {};\r\n      ctx.routes[method][path] = {\r\n        handler: async () => {\r\n          throw new Error(\"Not implemented!\");\r\n        },\r\n      };\r\n\r\n      return createRoute<\"\", unknown, unknown, unknown, unknown, Context, M>(\r\n        ctx.routes[method][path]\r\n      );\r\n    },\r\n    // @ts-expect-error wrong types\r\n    use(fn) {\r\n      // @ts-expect-error wrong types\r\n      ctx.middlewares.push(fn);\r\n      return proxy;\r\n    },\r\n    finish() {\r\n      return ctx;\r\n    },\r\n  };\r\n\r\n  const proxy = new Proxy(routerHandler, {\r\n    get(target, p, receiver) {\r\n      return Reflect.get(target, p, receiver);\r\n    },\r\n  });\r\n\r\n  return routerHandler;\r\n}\r\n\r\nexport class ControllerRegistry {\r\n  controllers = new Map<string, ControllerCtx>();\r\n  private readonly serviceRegistry: ServiceRegistry;\r\n\r\n  constructor(serviceRegistry: ServiceRegistry) {\r\n    this.serviceRegistry = serviceRegistry;\r\n  }\r\n\r\n  register(controller: Pick<ControllerC<{}>, \"finish\">) {\r\n    const controllerCtx = controller.finish(this.serviceRegistry);\r\n\r\n    if (this.controllers.has(controllerCtx.rootPath))\r\n      throw new Error(\r\n        `Controller with rootPath \"${controllerCtx.rootPath}\" already registered.`\r\n      );\r\n\r\n    this.controllers.set(controllerCtx.rootPath, controllerCtx);\r\n  }\r\n}\r\n","import { AsyncLocalStorage } from \"async_hooks\";\r\nimport { FastifyReply, FastifyRequest } from \"fastify\";\r\n\r\nconst contextLocalStorage = new AsyncLocalStorage<{\r\n  request: FastifyRequest;\r\n  reply: FastifyReply;\r\n}>();\r\n\r\nexport function getRequestContext() {\r\n  const store = contextLocalStorage.getStore();\r\n  if (!store)\r\n    throw new Error(\r\n      \"No context set, are you trying to access the context outside of a service function?\"\r\n    );\r\n\r\n  return store;\r\n}\r\n\r\nexport function setRequestContext(ctx: {\r\n  request: FastifyRequest;\r\n  reply: FastifyReply;\r\n}) {\r\n  return contextLocalStorage.enterWith(ctx);\r\n}\r\n","import { FastifyReply, FastifyRequest } from \"fastify\";\r\nimport { getRequestContext } from \"./context\";\r\nimport { QueueContainer, WorkerContainer, WorkerRegistry } from \"./worker\";\r\n\r\ntype ServiceScope = \"REQUEST\" | \"SINGLETON\";\r\n\r\ntype ServiceFactory<T, S extends ServiceScope> = (\r\n  opts: S extends \"SINGLETON\"\r\n    ? {\r\n        services: ServiceContainer;\r\n        workers: WorkerContainer;\r\n        queues: QueueContainer;\r\n      }\r\n    : {\r\n        services: ServiceContainer;\r\n        request: FastifyRequest;\r\n        reply: FastifyReply;\r\n        workers: WorkerContainer;\r\n        queues: QueueContainer;\r\n      }\r\n) => Promise<T>;\r\ntype Service<T, S extends ServiceScope> = {\r\n  name: string;\r\n  factory: ServiceFactory<T, S>;\r\n  scope: ServiceScope;\r\n};\r\nexport type ServiceContainer = {\r\n  get<T>(name: string): Promise<T>;\r\n};\r\n\r\nexport type InferService<S> = S extends {\r\n  name: string;\r\n  factory: ServiceFactory<infer T, infer S>;\r\n}\r\n  ? T\r\n  : never;\r\n\r\nexport class ServiceRegistry {\r\n  private readonly factories = new Map<\r\n    string,\r\n    { factory: ServiceFactory<any, any>; scope: ServiceScope }\r\n  >();\r\n  private readonly singletonInstances = new Map<string, any>();\r\n  private readonly workerRegistryRef: { current: WorkerRegistry | null };\r\n\r\n  constructor(workerRegistryRef: { current: WorkerRegistry | null }) {\r\n    this.workerRegistryRef = workerRegistryRef;\r\n  }\r\n\r\n  register<T, S extends ServiceScope>({\r\n    name,\r\n    factory,\r\n    scope,\r\n  }: Service<T, S>): void {\r\n    if (this.factories.has(name)) {\r\n      throw new Error(`Service \"${name}\" already registered.`);\r\n    }\r\n    this.factories.set(name, { factory, scope });\r\n  }\r\n\r\n  resolve(): ServiceContainer {\r\n    const requestScopedInstances = new Map<string, any>();\r\n    const resolving = new Set<string>();\r\n\r\n    const container: ServiceContainer = {\r\n      get: async <T>(name: string): Promise<T> => {\r\n        if (!this.workerRegistryRef.current)\r\n          throw new Error(\"Worker registry not registered yet!\");\r\n\r\n        const definition = this.factories.get(name);\r\n        if (!definition) {\r\n          throw new Error(`No service named \"${name}\" found!`);\r\n        }\r\n\r\n        const { factory, scope } = definition;\r\n\r\n        const cache =\r\n          scope === \"SINGLETON\"\r\n            ? this.singletonInstances\r\n            : requestScopedInstances;\r\n\r\n        if (cache.has(name)) {\r\n          return cache.get(name);\r\n        }\r\n\r\n        if (resolving.has(name)) {\r\n          throw new Error(\r\n            `Circular dependency detected while resolving \"${name}\"`\r\n          );\r\n        }\r\n\r\n        let instance: any;\r\n\r\n        resolving.add(name);\r\n        if (scope === \"REQUEST\") {\r\n          const ctx = getRequestContext();\r\n          instance = await factory({\r\n            services: container,\r\n            workers: { get: this.workerRegistryRef.current.getWorker },\r\n            queues: { get: this.workerRegistryRef.current.getQueue },\r\n            ...ctx,\r\n          });\r\n        } else {\r\n          instance = await factory({\r\n            services: container,\r\n            workers: { get: this.workerRegistryRef.current.getWorker },\r\n            queues: { get: this.workerRegistryRef.current.getQueue },\r\n          });\r\n        }\r\n        resolving.delete(name);\r\n\r\n        cache.set(name, instance);\r\n        return instance;\r\n      },\r\n    };\r\n\r\n    return container;\r\n  }\r\n}\r\n\r\nexport function createService<T, S extends ServiceScope>(\r\n  name: string,\r\n  factory: ServiceFactory<T, S>,\r\n  scope?: S\r\n) {\r\n  return { name, factory, scope: scope ?? (\"SINGLETON\" as S) };\r\n}\r\n","export function createMiddleware<\r\n  NewContext extends Record<string, unknown>,\r\n  NextContext extends NewContext,\r\n  Context extends Record<string, unknown> = {}\r\n>(\r\n  fn: (\r\n    opts: { ctx: Context },\r\n    next: (opts: { ctx: NewContext }) => Promise<void>\r\n  ) => Promise<NextContext>\r\n) {\r\n  return fn;\r\n}\r\n"]}