import {Queue,Worker}from'bullmq';export{Job,Queue}from'bullmq';import {AsyncLocalStorage}from'async_hooks';var a=class{constructor(t){this.queues=new Map;this.workers=new Map;this.serviceRegistry=t;}async register(t){if(this.queues.has(t.queueName))throw new Error(`Queue with name "${t.queueName}" is already registered.`);let o=new Queue(t.queueName,{...t.queueOptions,connection:t.connection});this.queues.set(o.name,o);for(let n of t.jobSchedulers)await o.upsertJobScheduler(...n);if(this.workers.has(t.queueName))throw new Error(`Queue with name "${t.queueName}" is already registered.`);let e=new Worker(t.queueName,typeof t.processor=="function"?async(n,s)=>{if(typeof t.processor!="function")throw new Error("Something went wrong!");return t.processor(n,{services:this.serviceRegistry.resolve(),workers:{get:this.getWorker.bind(this)},queues:{get:this.getQueue.bind(this)}},s)}:t.processor,{...t.options,connection:t.connection});for(let n of t.onHandlers)e.on(...n);for(let n of t.onceHandlers)e.once(...n);this.workers.set(t.queueName,e);}getQueue(t){let o=this.queues.get(t);if(!o)throw new Error(`No queue named "${t}" found.`);return o}getWorker(t){let o=this.workers.get(t);if(!o)throw new Error(`No Worker named "${t}" found.`);return o}};function f(){let r={queueName:"",jobSchedulers:[],onceHandlers:[],queue:null,connection:{},worker:null,processor:"",onHandlers:[],isSandboxed:false},t={queue(e,n){return r.queueOptions=n,r.queueName=e,o},connection(e){return r.connection=e,o},job(){return r.isSandboxed=false,o},on(...e){return r.onHandlers.push(e),o},once(...e){return r.onceHandlers.push(e),o},options(e){return r.options=e,o},processor(e){return r.processor=e,r},sandboxedJob(){return r.isSandboxed=true,o},upsertJobScheduler(...e){return r.jobSchedulers.push(e),o}},o=new Proxy(t,{get(e,n,s){return Reflect.get(e,n,s)}});return t}function l(r){let t={body(e){return r.body=e,o},output(e){return r.output=e,o},params(e){return r.params=e,o},querystring(e){return r.querystring=e,o},handler(e,n){return r.handler=e,r.opts=n,r}},o=new Proxy(t,{get(e,n,s){return Reflect.get(e,n,s)}});return t}function h(){let r={rootPath:"",middlewares:[],routes:{}},t={rootPath(e){return r.rootPath=e,o},addRoute(e,n){if(r.routes[e]?.[n])throw new Error(`${e} Route "${r.rootPath}${n}" already registered.`);return r.routes[e]||(r.routes[e]={}),r.routes[e][n]={handler:async()=>{throw new Error("Not implemented!")}},l(r.routes[e][n])},use(e){return r.middlewares.push(e),o},finish(){return r}},o=new Proxy(t,{get(e,n,s){return Reflect.get(e,n,s)}});return t}var c=class{constructor(t){this.controllers=new Map;this.serviceRegistry=t;}register(t){let o=t.finish(this.serviceRegistry);if(this.controllers.has(o.rootPath))throw new Error(`Controller with rootPath "${o.rootPath}" already registered.`);this.controllers.set(o.rootPath,o);}};var C=new AsyncLocalStorage;function x(){let r=C.getStore();if(!r)throw new Error("No context set, are you trying to access the context outside of a service function?");return r}var d=class{constructor(t){this.factories=new Map;this.singletonInstances=new Map;this.workerRegistryRef=t;}register({name:t,factory:o,scope:e}){if(this.factories.has(t))throw new Error(`Service "${t}" already registered.`);this.factories.set(t,{factory:o,scope:e});}resolve(){let t=new Map,o=new Set,e={get:async n=>{if(!this.workerRegistryRef.current)throw new Error("Worker registry not registered yet!");let s=this.factories.get(n);if(!s)throw new Error(`No service named "${n}" found!`);let{factory:y,scope:p}=s,u=p==="SINGLETON"?this.singletonInstances:t;if(u.has(n))return u.get(n);if(o.has(n))throw new Error(`Circular dependency detected while resolving "${n}"`);let i;if(o.add(n),p==="REQUEST"){let g=x();i=await y({services:e,workers:{get:this.workerRegistryRef.current.getWorker},queues:{get:this.workerRegistryRef.current.getQueue},...g});}else i=await y({services:e,workers:{get:this.workerRegistryRef.current.getWorker},queues:{get:this.workerRegistryRef.current.getQueue}});return o.delete(n),u.set(n,i),i}};return e}};function k(r,t,o){return {name:r,factory:t,scope:o??"SINGLETON"}}function O(r){return r}export{c as ControllerRegistry,d as ServiceRegistry,a as WorkerRegistry,h as createController,O as createMiddleware,k as createService,f as createWorker};//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map