import {Queue,Worker}from'bullmq';export{Job,Queue}from'bullmq';import {AsyncLocalStorage}from'async_hooks';var c=class{constructor(e){this.queues=new Map;this.workers=new Map;this.serviceRegistry=e;}async register(e){if(this.queues.has(e.queueName))throw new Error(`Queue with name "${e.queueName}" is already registered.`);let o=new Queue(e.queueName,{...e.queueOptions,connection:e.connection});this.queues.set(o.name,o);for(let n of e.jobSchedulers)await o.upsertJobScheduler(...n);if(this.workers.has(e.queueName))throw new Error(`Queue with name "${e.queueName}" is already registered.`);let t=new Worker(e.queueName,typeof e.processor=="function"?async(n,s)=>{if(typeof e.processor!="function")throw new Error("Processor was not a function but was expected to be one.");try{return await e.processor(n,{services:this.serviceRegistry.resolve(),workers:{get:this.getWorker.bind(this)},queues:{get:this.getQueue.bind(this)}},s)}catch(i){throw console.error(`Error in processor ${e.queueName}`,i),i}}:e.processor,{...e.options,connection:e.connection});for(let n of e.onHandlers)t.on(n[0],async(...s)=>{try{return await n[1](...s)}catch(i){console.error(`Error in worker on "${n[0]}" handler.`,i);}});for(let n of e.onceHandlers)t.once(n[0],async(...s)=>{try{return await n[1](...s)}catch(i){console.error(`Error in worker once "${n[0]}" handler.`,i);}});this.workers.set(e.queueName,t);}getQueue(e){let o=this.queues.get(e);if(!o)throw new Error(`No queue named "${e}" found.`);return o}getWorker(e){let o=this.workers.get(e);if(!o)throw new Error(`No Worker named "${e}" found.`);return o}};function f(){let r={queueName:"",jobSchedulers:[],onceHandlers:[],queue:null,connection:{},worker:null,processor:"",onHandlers:[],isSandboxed:false},e={queue(t,n){return r.queueOptions=n,r.queueName=t,o},connection(t){return r.connection=t,o},job(){return r.isSandboxed=false,o},on(...t){return r.onHandlers.push(t),o},once(...t){return r.onceHandlers.push(t),o},options(t){return r.options=t,o},processor(t){return r.processor=t,r},sandboxedJob(){return r.isSandboxed=true,o},upsertJobScheduler(...t){return r.jobSchedulers.push(t),o}},o=new Proxy(e,{get(t,n,s){return Reflect.get(t,n,s)}});return e}function l(r){let e={body(t){return r.body=t,o},output(t){return r.output=t,o},params(t){return r.params=t,o},querystring(t){return r.querystring=t,o},handler(t,n){return r.handler=t,r.opts=n,r}},o=new Proxy(e,{get(t,n,s){return Reflect.get(t,n,s)}});return e}function h(){let r={rootPath:"",middlewares:[],routes:{}},e={rootPath(t){return r.rootPath=t,o},addRoute(t,n){if(r.routes[t]?.[n])throw new Error(`${t} Route "${r.rootPath}${n}" already registered.`);return r.routes[t]||(r.routes[t]={}),r.routes[t][n]={handler:async()=>{throw new Error("Not implemented!")}},l(r.routes[t][n])},use(t){return r.middlewares.push(t),o},finish(){return r}},o=new Proxy(e,{get(t,n,s){return Reflect.get(t,n,s)}});return e}var d=class{constructor(e){this.controllers=new Map;this.serviceRegistry=e;}register(e){let o=e.finish(this.serviceRegistry);if(this.controllers.has(o.rootPath))throw new Error(`Controller with rootPath "${o.rootPath}" already registered.`);this.controllers.set(o.rootPath,o);}};var k=new AsyncLocalStorage;function x(){let r=k.getStore();if(!r)throw new Error("No context set, are you trying to access the context outside of a service function?");return r}var y=class{constructor(e){this.factories=new Map;this.singletonInstances=new Map;this.workerRegistryRef=e;}register({name:e,factory:o,scope:t}){if(this.factories.has(e))throw new Error(`Service "${e}" already registered.`);this.factories.set(e,{factory:o,scope:t});}resolve(){let e=new Map,o=new Set,t={get:async n=>{if(!this.workerRegistryRef.current)throw new Error("Worker registry not registered yet!");let s=this.factories.get(n);if(!s)throw new Error(`No service named "${n}" found!`);let{factory:i,scope:p}=s,a=p==="SINGLETON"?this.singletonInstances:e;if(a.has(n))return a.get(n);if(o.has(n))throw new Error(`Circular dependency detected while resolving "${n}"`);let u;if(o.add(n),p==="REQUEST"){let g=x();u=await i({services:t,workers:{get:this.workerRegistryRef.current.getWorker},queues:{get:this.workerRegistryRef.current.getQueue},...g});}else u=await i({services:t,workers:{get:this.workerRegistryRef.current.getWorker},queues:{get:this.workerRegistryRef.current.getQueue}});return o.delete(n),a.set(n,u),u}};return t}};function C(r,e,o){return {name:r,factory:e,scope:o??"SINGLETON"}}function O(r){return r}export{d as ControllerRegistry,y as ServiceRegistry,c as WorkerRegistry,h as createController,O as createMiddleware,C as createService,f as createWorker};//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map